---
phase: 12-integration-polish
plan: 04
type: execute
wave: 3
depends_on:
  - 12-01
  - 12-02
  - 12-03
files_modified:
  - bot/handlers.py
  - bot/main.py
  - tests/integration/test_download_flow.py
autonomous: true

must_haves:
  truths:
    - "Download + Convert flow works end-to-end"
    - "Download + Audio Extract flow works end-to-end"
    - "Download + Voice Note flow works end-to-end"
    - "All error cases handled gracefully"
  artifacts:
    - path: tests/integration/test_download_flow.py
      provides: "End-to-end integration tests"
      contains: "test_download_and_convert, test_download_and_extract"
    - path: bot/handlers.py
      provides: "Polished integration handlers"
      contains: "Combined download+process workflows"
  key_links:
    - from: tests/integration/test_download_flow.py
      to: bot/handlers.py
      via: "Integration testing"
      pattern: "test_.*download"
---

<objective>
Implement "Download + Convert" combined flow and add end-to-end integration tests for the complete download system.

Purpose: Provide streamlined workflows that combine download and processing into single user actions, and ensure all download functionality works correctly together.
Output: Combined action handlers, comprehensive integration tests, error handling polish.
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@bot/handlers.py
@bot/downloaders/download_facade.py
@bot/downloaders/__init__.py

## Phase Context

Combined flow requirements (INT-03):
- "Download + Convert" should allow downloading and immediately processing
- Reduces user steps from: download -> wait -> click menu -> process
- To: select "Download + Convert" -> wait -> receive processed file

Existing patterns from Phase 8:
- Menu callbacks use pattern `action:type` or `action:type:id`
- Combined actions can use `download_action:format:process` pattern

Integration testing:
- Test full download flow with mocked external services
- Test error handling paths
- Test cancellation
- Test post-download processing

Dependencies:
- 12-01, 12-02, 12-03 must be complete
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Download + Convert combined flow</name>
  <files>bot/handlers.py</files>
  <action>
Add "Download + Convert" option to format selection menu:

1. Update `_get_download_format_keyboard()` to include combined options:
   ```python
   def _get_download_format_keyboard(correlation_id, url_metadata=None):
       keyboard = [
           [
               InlineKeyboardButton("Video", callback_data=f"download:video:{correlation_id}"),
               InlineKeyboardButton("Audio", callback_data=f"download:audio:{correlation_id}"),
           ],
           [
               InlineKeyboardButton("Video + Nota de Video", callback_data=f"download:video:videonote:{correlation_id}"),
               InlineKeyboardButton("Video + Extraer Audio", callback_data=f"download:video:extract:{correlation_id}"),
           ],
           [
               InlineKeyboardButton("Audio + Nota de Voz", callback_data=f"download:audio:voicenote:{correlation_id}"),
           ],
           [InlineKeyboardButton("Cancelar", callback_data="cancel")],
       ]
       return InlineKeyboardMarkup(keyboard)
   ```

2. Update `handle_download_format_callback()` to handle combined actions:
   - Parse callback: `download:format:action:correlation_id` or `download:format:correlation_id`
   - If 4 parts: format + process action
   - If 3 parts: format only (existing behavior)
   - Store intended action in context.user_data for post-download

3. Implement combined download handler:
   ```python
   async def handle_combined_download(
       update, context, url, format_type, post_action, correlation_id
   ):
       """Download and immediately process."""
       # Download with progress
       facade = DownloadFacade()
       await facade.start()

       config_overrides = {"extract_audio": format_type == "audio"}

       try:
           result = await facade.download_with_progress(
               url=url,
               message_func=lambda text: context.bot.send_message(
                   update.effective_chat.id, text
               ),
               edit_message_func=lambda text: status_message.edit_text(text),
               config_overrides=config_overrides
           )

           if result.success:
               # Immediately process based on post_action
               if post_action == "videonote":
                   await process_to_videonote(update, context, result)
               elif post_action == "extract":
                   await process_extract_audio(update, context, result)
               elif post_action == "voicenote":
                   await process_to_voicenote(update, context, result)
           else:
               await status_message.edit_text("Error en la descarga")

       finally:
           await facade.stop()
   ```

4. Implement process helpers:
   - `process_to_videonote()` - Convert downloaded video to video note
   - `process_extract_audio()` - Extract audio from downloaded video
   - `process_to_voicenote()` - Convert downloaded audio to voice note
   - Each shows progress, handles errors, sends result

5. Update confirmation flow for combined actions:
   - Show "Video + Nota de Video" will download then convert
   - Size check applies to download only (processing may change size)
   - Clear messaging about the two-step process

6. Add to format selection message:
   ```
   Selecciona formato:
   - Video: Solo descargar video
   - Audio: Solo extraer audio
   - Video + Nota de Video: Descargar y convertir a nota circular
   - Video + Extraer Audio: Descargar y extraer audio
   - Audio + Nota de Voz: Descargar y convertir a nota de voz
   ```
  </action>
  <verify>
    grep -n "download:video:videonote\|handle_combined_download\|process_to_videonote" bot/handlers.py | head -20
  </verify>
  <done>
    Combined flow options in format menu. Handlers parse combined actions. Process helpers convert downloaded files. Two-step flow works end-to-end.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add error handling and edge case polish</name>
  <files>bot/handlers.py</files>
  <action>
Polish error handling for all download flows:

1. Handle network errors during download:
   - Connection reset: retry once, then fail gracefully
   - Timeout: show "La descarga tardó demasiado, intenta de nuevo"
   - DNS failure: "No se pudo conectar al servidor"

2. Handle platform-specific errors:
   - YouTube age-restricted: already handled in YtDlpDownloader
   - Instagram private: "Este contenido es privado"
   - TikTok slideshow: "Los slideshows de TikTok no son soportados"
   - Facebook login required: "Este video requiere inicio de sesión"
   - Generic: "Error al descargar de {platform}"

3. Handle file system errors:
   - Disk full: "No hay espacio suficiente en el servidor"
   - Permission denied: "Error de permisos al guardar archivo"
   - Temp directory issues: "Error temporal, intenta de nuevo"

4. Handle Telegram errors:
   - File too large for Telegram: "El archivo excede el límite de Telegram (50MB)"
   - Send failed: "Error al enviar el archivo, intenta de nuevo"
   - Rate limited: "Demasiadas solicitudes, espera un momento"

5. Add user-friendly error recovery:
   - Retry button for transient errors
   - Try different format option
   - Contact support message for persistent errors

6. Cleanup on all error paths:
   - Cancel active downloads
   - Clean up temp files
   - Remove user_data entries
   - Stop facade

7. Add logging for debugging:
   - Log all errors with correlation_id
   - Log user_id for support requests
   - Log platform and URL (sanitized)

8. Edge cases:
   - User sends multiple URLs quickly: queue them
   - User cancels during confirmation: clean state
   - Download completes but file deleted: show error
   - Processing fails after download: show partial success
   - Bot restarted during download: handle gracefully
  </action>
  <verify>
    grep -n "except.*Error\|logger.error.*download" bot/handlers.py | wc -l
  </verify>
  <done>
    All error types handled with Spanish messages. Recovery options provided. Cleanup on all paths. Comprehensive logging. Edge cases covered.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create integration tests</name>
  <files>tests/integration/test_download_flow.py</files>
  <action>
Create comprehensive integration tests:

1. Create test file structure:
   ```python
   """Integration tests for download flow."""
   import pytest
   import asyncio
   from unittest.mock import AsyncMock, MagicMock, patch
   from telegram import Update, Message, User, Chat

   from bot.handlers import (
       handle_download_command,
       handle_url_detection,
       handle_download_format_callback,
       handle_postdownload_callback,
   )
   from bot.downloaders import DownloadFacade
   ```

2. Test basic download flow:
   ```python
   async def test_download_command_shows_format_menu():
       """Test /download command shows format selection."""
       # Mock update with URL
       update = create_mock_update(text="/download https://youtube.com/watch?v=test")
       context = create_mock_context()

       await handle_download_command(update, context)

       # Verify format menu shown
       assert context.bot.send_message.called
       assert "Selecciona formato" in context.bot.send_message.call_args[1]["text"]
   ```

3. Test URL detection:
   ```python
   async def test_url_detection_in_message():
       """Test URL in regular message triggers menu."""
       update = create_mock_update(text="Check this video: https://youtube.com/watch?v=test")
       context = create_mock_context()

       await handle_url_detection(update, context)

       # Verify menu shown
       assert update.message.reply_text.called
   ```

4. Test format selection:
   ```python
   async def test_format_selection_triggers_download():
       """Test selecting format starts download."""
       update = create_mock_callback_update(data="download:video:test123")
       context = create_mock_context()
       context.user_data["download_url_test123"] = "https://youtube.com/watch?v=test"

       with patch("bot.handlers.DownloadFacade") as mock_facade:
           mock_instance = AsyncMock()
           mock_facade.return_value = mock_instance

           await handle_download_format_callback(update, context)

           # Verify download started
           assert mock_instance.start.called
           assert mock_instance.download_with_progress.called
   ```

5. Test combined flow:
   ```python
   async def test_download_and_convert_flow():
       """Test download + videonote combined flow."""
       update = create_mock_callback_update(data="download:video:videonote:test123")
       context = create_mock_context()

       with patch("bot.handlers.process_to_videonote") as mock_process:
           mock_process.return_value = AsyncMock()

           await handle_combined_download(update, context, ...)

           # Verify process called after download
           assert mock_process.called
   ```

6. Test cancellation:
   ```python
   async def test_cancel_during_download():
       """Test cancel button stops download."""
       update = create_mock_callback_update(data="download:cancel:test123")
       context = create_mock_context()
       context.user_data["download_facade_test123"] = AsyncMock()

       await handle_download_cancel_callback(update, context)

       # Verify cancel called
       facade = context.user_data["download_facade_test123"]
       assert facade.cancel_download.called
   ```

7. Test error handling:
   ```python
   async def test_large_file_shows_confirmation():
       """Test >50MB file triggers confirmation."""
       # Mock metadata with large size
       with patch("bot.handlers.get_metadata") as mock_meta:
           mock_meta.return_value = {"filesize": 100 * 1024 * 1024}

           await handle_download_format_callback(update, context)

           # Verify confirmation shown
           assert "grande" in update.callback_query.edit_message_text.call_args[1]["text"]
   ```

8. Test post-download processing:
   ```python
   async def test_postdownload_videonote_conversion():
       """Test converting downloaded video to videonote."""
       update = create_mock_callback_update(data="postdownload:videonote:test123")
       context = create_mock_context()
       # Add entry to DownloadSession

       with patch("bot.handlers.VideoProcessor") as mock_processor:
           await handle_postdownload_callback(update, context)

           assert mock_processor.process_video.called
   ```

9. Add test fixtures:
   ```python
   @pytest.fixture
   def mock_update():
       """Create mock update object."""
       update = MagicMock(spec=Update)
       update.effective_user = MagicMock(spec=User, id=12345)
       update.effective_chat = MagicMock(spec=Chat, id=67890)
       update.message = MagicMock(spec=Message)
       return update

   @pytest.fixture
   def mock_context():
       """Create mock context."""
       context = MagicMock()
       context.user_data = {}
       context.bot = AsyncMock()
       return context
   ```

10. Run tests:
    ```bash
    python -m pytest tests/integration/test_download_flow.py -v
    ```
  </action>
  <verify>
    python -m pytest tests/integration/test_download_flow.py -v --tb=short 2>&1 | head -50
  </verify>
  <done>
    Integration tests cover: basic flow, URL detection, format selection, combined flow, cancellation, error handling, post-download processing. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 4: Final polish and handler registration</name>
  <files>bot/main.py, bot/handlers.py</files>
  <action>
Final integration and polish:

1. Update main.py with all new handlers:
   ```python
   from bot.handlers import (
       # ... existing imports ...
       handle_combined_download,
       handle_process_to_videonote,
       handle_process_to_voicenote,
       handle_process_extract_audio,
   )
   ```

2. Register combined flow handlers:
   ```python
   # Combined download+process callbacks
   application.add_handler(CallbackQueryHandler(
       handle_combined_download,
       pattern="^download:(video|audio):(videonote|extract|voicenote):"
   ))
   ```

3. Polish handler imports:
   - Ensure all handlers exported from handlers.py
   - Check for circular imports
   - Verify async/await consistency

4. Add startup logging:
   ```python
   logger.info("Download handlers registered")
   logger.info("Post-download integration enabled")
   ```

5. Update /start command help:
   ```python
   "También puedes enviarme un enlace de video y te ayudaré a descargarlo.\n"
   "Soporto: YouTube, Instagram, TikTok, Twitter/X, Facebook\n\n"
   "/download <url> - Descargar video/audio de un enlace"
   ```

6. Final code review checklist:
   - [ ] All handlers registered
   - [ ] Callback patterns correct
   - [ ] Error handling comprehensive
   - [ ] Spanish messages throughout
   - [ ] No debug code left
   - [ ] Logging appropriate
   - [ ] Cleanup on all paths
   - [ ] Tests pass

7. Run full test suite:
   ```bash
   python -m pytest tests/ -v --tb=short
   ```

8. Test manually with bot:
   - /download with YouTube URL
   - URL in regular message
   - Format selection
   - Cancel during download
   - Post-download video note
   - Post-download audio processing
   - Combined download+convert
  </action>
  <verify>
    python -c "from bot.handlers import handle_download_command, handle_url_detection, handle_combined_download; print('All imports OK')"
  </verify>
  <done>
    All handlers registered. Combined flow callbacks configured. Help text updated. Tests pass. Ready for integration.
  </done>
</task>

</tasks>

<verification>
- Download + Video Note flow works end-to-end
- Download + Audio Extract flow works end-to-end
- Download + Voice Note flow works end-to-end
- All integration tests pass
- Error handling works for all error types
- Help text includes download commands
</verification>

<success_criteria>
1. Combined download+process options in format menu
2. Download + Video Note works seamlessly
3. Download + Audio Extract works seamlessly
4. Download + Voice Note works seamlessly
5. All integration tests pass
6. Error handling polished and user-friendly
7. All handlers properly registered
</success_criteria>

<output>
After completion, create `.planning/phases/12-integration-polish/12-04-SUMMARY.md`
</output>
