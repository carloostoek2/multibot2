---
phase: 01.1-expandir-procesamiento-video
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/split_processor.py
  - bot/handlers.py
  - bot/error_handler.py
autonomous: true

must_haves:
  truths:
    - "User can split a video into multiple segments by duration (e.g., 30-second chunks)"
    - "User can split a video into a specific number of equal parts"
    - "User receives all segments as separate video files"
    - "Each segment is a valid, playable video file"
  artifacts:
    - path: "bot/split_processor.py"
      provides: "VideoSplitter class"
      exports: ["VideoSplitter"]
    - path: "bot/handlers.py"
      provides: "Command handler for /split"
  key_links:
    - from: "bot/handlers.py"
      to: "bot/split_processor.py"
      via: "import and call VideoSplitter.split_by_duration/split_by_parts"
    - from: "bot/split_processor.py"
      to: "bot/error_handler.py"
      via: "raise VideoSplitError"
---

<objective>
Implement video splitting functionality to divide videos into segments.

Purpose: Allow users to split long videos into smaller chunks by duration or number of parts.
Output: VideoSplitter class with Telegram command handler.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bot/video_processor.py
@bot/handlers.py
@bot/error_handler.py
@bot/temp_manager.py

# Existing patterns:
- VideoProcessor uses ffmpeg via subprocess
- Handlers use async/await with timeout protection
- TempManager for automatic cleanup
- Spanish user messages
- Custom exceptions in error_handler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create VideoSplitter class</name>
  <files>bot/split_processor.py</files>
  <action>
    Create bot/split_processor.py with VideoSplitter class:

    1. VideoSplitter class with methods:
       - __init__(self, input_path: str, output_dir: str)
       - split_by_duration(self, segment_duration: int) -> list[str] - Split into chunks of N seconds
       - split_by_parts(self, num_parts: int) -> list[str] - Split into N equal parts
       - get_video_duration(self) -> float - Get total video duration using ffprobe

    2. Implementation details:
       - Use ffprobe to get video duration: ffprobe -v error -show_entries format=duration -of csv=p=0 input.mp4
       - For split_by_duration: Calculate number of segments, use ffmpeg segment filter
       - For split_by_parts: Calculate segment duration from total duration

    3. ffmpeg segment command structure:
       ffmpeg -i input.mp4 -c copy -map 0 -segment_time {duration} -f segment -reset_timestamps 1 output_%03d.mp4

    4. Output file naming:
       - Use pattern: {basename}_part{NNN}.{ext}
       - Return list of output file paths

    5. Follow existing patterns:
       - _check_ffmpeg() and _check_ffprobe() static methods
       - Path validation
       - subprocess.run with error handling
       - Comprehensive logging
       - Return empty list on failure

    6. Add custom exception VideoSplitError to error_handler.py
  </action>
  <verify>
    - File exists: bot/split_processor.py
    - VideoSplitter class exists with split_by_duration and split_by_parts methods
    - ffprobe integration works for duration detection
    - Segment naming pattern is correct
  </verify>
  <done>
    VideoSplitter class created with duration-based and parts-based splitting
  </done>
</task>

<task type="auto">
  <name>Task 2: Add /split command handler</name>
  <files>bot/handlers.py, bot/main.py</files>
  <action>
    Update handlers.py and main.py for video splitting:

    1. In handlers.py, add handle_split_command(update, context):
       - Parse command arguments: /split duration 30 or /split parts 4
       - Default to duration 60 if no arguments provided
       - Validate arguments (positive integers only)

    2. Command usage patterns:
       - /split duration 30 - Split into 30-second segments
       - /split parts 5 - Split into 5 equal parts
       - /split (alone) - Default 60-second segments

    3. Implementation flow:
       - Check if command is reply to a video
       - Download video to temp directory
       - Call VideoSplitter with appropriate method
       - Send each segment back to user
       - Report progress ("Enviando parte 1 de 5...")

    4. Constraints:
       - Maximum 10 segments per operation (prevent spam)
       - Minimum 5 seconds per segment
       - Use TempManager for cleanup
       - Apply PROCESSING_TIMEOUT

    5. In main.py, register handler:
       - CommandHandler("split", handle_split_command)

    6. Error handling:
       - VideoSplitError: "No pude dividir el video"
       - Too many segments: "El video generaría demasiadas partes. Intenta con una duración mayor."
       - Not a reply: "Responde a un video con este comando para dividirlo."
  </action>
  <verify>
    - /split command registered and functional
    - Works when replying to video messages
    - Respects max 10 segments limit
    - Sends all segments to user
  </verify>
  <done>
    /split command working with duration and parts modes, max 10 segments limit
  </done>
</task>

</tasks>

<verification>
1. Send a 2-minute video with /split duration 30 - receive 4 segments
2. Send a 5-minute video with /split parts 5 - receive 5 equal segments
3. Verify error message when trying to create >10 segments
4. Check temp files cleaned up after all segments sent
</verification>

<success_criteria>
- VideoSplitter splits by duration (seconds) correctly
- VideoSplitter splits by number of parts correctly
- Maximum 10 segments per operation enforced
- Minimum 5 seconds per segment enforced
- All segments sent as separate video files
- Progress messages inform user during sending
- Spanish error messages for all error cases
- Temp files cleaned up automatically
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-expandir-procesamiento-video/01.1-02-SUMMARY.md`
</output>
