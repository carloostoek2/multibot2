---
phase: 08-interfaz-usuario-menu-inline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/handlers.py
autonomous: true

must_haves:
  truths:
    - "Al recibir un archivo de video, el bot presenta automáticamente un menú inline con opciones disponibles"
    - "El menú de video muestra opciones relevantes: nota de video, extraer audio, convertir formato"
    - "Las selecciones del menú de video ejecutan la funcionalidad correspondiente"
    - "Los comandos existentes de video siguen funcionando (backward compatibility)"
  artifacts:
    - path: "bot/handlers.py"
      provides: "Video inline menu handlers and callbacks"
      contains: ["handle_video_menu", "handle_video_menu_callback", "_get_video_menu_keyboard"]
  key_links:
    - from: "handle_video"
      to: "_get_video_menu_keyboard"
      via: "inline keyboard generation"
    - from: "handle_video_menu_callback"
      to: "existing video handlers"
      via: "callback routing to existing logic"
---

<objective>
Implementar menú inline contextual para archivos de video que se muestra automáticamente cuando el usuario envía un video, permitiendo acceder a todas las funcionalidades de video sin necesidad de comandos.

Purpose: Eliminar la necesidad de que los usuarios aprendan comandos para usar las funcionalidades de video del bot.
Output: Handlers para mostrar menú inline de video y procesar selecciones, integrados con la lógica existente.
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@/data/data/com.termux/files/home/repos/multibot2/bot/handlers.py
@/data/data/com.termux/files/home/repos/multibot2/bot/main.py

## Existing Video Handlers (for reference)

The following video handlers exist and must remain functional:
- `handle_video`: Converts video to video note (automatic on video upload)
- `handle_convert_command`: /convert <formato> - Converts video format
- `handle_extract_audio_command`: /extract_audio <formato> - Extracts audio from video
- `handle_split_command`: /split [duration|parts] <valor> - Splits video
- `handle_join_start/done/cancel`: /join - Joins multiple videos

## Existing Callback Patterns

The codebase uses these callback patterns:
- `format:<format>` - Format selection (e.g., format:mp3)
- `video_action:<action>` - NEW pattern for video menu
- `video_format:<format>` - NEW pattern for video format selection
- `video_audio_format:<format>` - NEW pattern for audio extraction format

## Inline Keyboard Pattern

```python
from telegram import InlineKeyboardMarkup, InlineKeyboardButton

keyboard = [
    [InlineKeyboardButton("Text", callback_data="callback:data")],
]
reply_markup = InlineKeyboardMarkup(keyboard)
```

## Context Storage Pattern

```python
context.user_data["key"] = value
file_id = context.user_data.get("key")
context.user_data.pop("key", None)  # Clean up
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create video inline menu keyboard generator</name>
  <files>bot/handlers.py</files>
  <action>
    Add a new function `_get_video_menu_keyboard()` that generates an InlineKeyboardMarkup with video action options.

    The keyboard should have 2 rows:
    - Row 1: ["Nota de Video", "Extraer Audio"]
    - Row 2: ["Convertir Formato", "Dividir Video"]

    Use callback_data pattern: `video_action:<action>` where action is one of:
    - `videonote` - Convert to video note
    - `extract_audio` - Extract audio from video
    - `convert` - Convert video format
    - `split` - Split video

    Example implementation:
    ```python
def _get_video_menu_keyboard() -> InlineKeyboardMarkup:
    """Generate inline keyboard for video menu options."""
    keyboard = [
        [
            InlineKeyboardButton("Nota de Video", callback_data="video_action:videonote"),
            InlineKeyboardButton("Extraer Audio", callback_data="video_action:extract_audio"),
        ],
        [
            InlineKeyboardButton("Convertir Formato", callback_data="video_action:convert"),
            InlineKeyboardButton("Dividir Video", callback_data="video_action:split"),
        ],
    ]
    return InlineKeyboardMarkup(keyboard)
    ```

    Place this function near other keyboard generators in the file (around line 2697 where `_get_equalizer_keyboard` is defined).
  </action>
  <verify>grep -n "_get_video_menu_keyboard" /data/data/com.termux/files/home/repos/multibot2/bot/handlers.py</verify>
  <done>Function `_get_video_menu_keyboard` exists and returns InlineKeyboardMarkup with 4 video action buttons in 2 rows</done>
</task>

<task type="auto">
  <name>Task 2: Modify handle_video to show inline menu instead of auto-processing</name>
  <files>bot/handlers.py</files>
  <action>
    Modify the `handle_video` function (currently lines 173-243) to show an inline menu instead of automatically processing the video to video note.

    Changes needed:
    1. Store the video file_id in context.user_data with key `video_menu_file_id`
    2. Store correlation_id in context.user_data with key `video_menu_correlation_id`
    3. Instead of calling `_process_video_with_timeout`, send a message with the inline keyboard
    4. The message should say: "Video recibido. Selecciona una acción:"
    5. Include the inline keyboard from `_get_video_menu_keyboard()`

    The validation logic (file size check) should remain at the beginning.
    Remove or comment out the TempManager processing block - it will be handled by the callback handler.

    Example structure:
    ```python
async def handle_video(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # ... existing validation code ...

    # Store file info for callback handler
    context.user_data["video_menu_file_id"] = video.file_id
    context.user_data["video_menu_correlation_id"] = correlation_id

    # Show inline menu
    reply_markup = _get_video_menu_keyboard()
    await update.message.reply_text(
        "Video recibido. Selecciona una acción:",
        reply_markup=reply_markup
    )
    ```

    IMPORTANT: Keep all the existing validation (file size, etc.) at the beginning of the function.
  </action>
  <verify>grep -A 20 "async def handle_video" /data/data/com.termux/files/home/repos/multibot2/bot/handlers.py | grep -E "video_menu_file_id|video_menu_correlation_id|_get_video_menu_keyboard"</verify>
  <done>handle_video stores file_id and correlation_id in context.user_data and shows inline menu with _get_video_menu_keyboard()</done>
</task>

<task type="auto">
  <name>Task 3: Create video menu callback handler</name>
  <files>bot/handlers.py</files>
  <action>
    Create a new async function `handle_video_menu_callback(update: Update, context: ContextTypes.DEFAULT_TYPE)` that handles video menu selections.

    The handler should:
    1. Parse callback data (format: `video_action:<action>`)
    2. Retrieve file_id from context.user_data["video_menu_file_id"]
    3. Route to appropriate action:
       - `videonote`: Process video to video note (reuse existing logic from _process_video_with_timeout)
       - `extract_audio`: Show format selection keyboard for audio extraction
       - `convert`: Show format selection keyboard for video conversion
       - `split`: Show split options or prompt for split parameters

    For `videonote` action:
    - Call `query.edit_message_text("Procesando video a nota de video...")`
    - Download and process the video similar to existing `_process_video_with_timeout` logic
    - Send as video note using `update.callback_query.message.reply_video_note()`
    - Edit message to confirm completion

    For `extract_audio` action:
    - Store action type in context.user_data["video_menu_action"] = "extract_audio"
    - Show format selection keyboard with audio formats (MP3, AAC, WAV, OGG)
    - Use callback pattern: `video_audio_format:<format>`

    For `convert` action:
    - Store action type in context.user_data["video_menu_action"] = "convert"
    - Show format selection keyboard with video formats (MP4, AVI, MOV, MKV, WEBM)
    - Use callback pattern: `video_format:<format>`

    For `split` action:
    - Edit message to request split parameters
    - Store action state and handle via separate flow or command

    Place this handler after the existing callback handlers in the file (after handle_pipeline_builder around line 3928).

    IMPORTANT: Always call `await query.answer()` at the start of the handler.
    Clean up context.user_data keys after processing: video_menu_file_id, video_menu_correlation_id, video_menu_action
  </action>
  <verify>grep -n "async def handle_video_menu_callback" /data/data/com.termux/files/home/repos/multibot2/bot/handlers.py</verify>
  <done>Function handle_video_menu_callback exists and handles video_action callbacks with routing to videonote, extract_audio, convert, and split actions</done>
</task>

<task type="auto">
  <name>Task 4: Create video format selection callback handler</name>
  <files>bot/handlers.py</files>
  <action>
    Create a new async function `handle_video_format_selection(update: Update, context: ContextTypes.DEFAULT_TYPE)` that handles video format selection callbacks.

    Callback patterns to handle:
    - `video_format:<format>` - For video format conversion (mp4, avi, mov, mkv, webm)
    - `video_audio_format:<format>` - For audio extraction from video (mp3, aac, wav, ogg)

    The handler should:
    1. Parse callback data to extract format
    2. Retrieve file_id from context.user_data["video_menu_file_id"]
    3. Retrieve action type from context.user_data["video_menu_action"]
    4. Process based on action type:

    For video conversion:
    - Edit message to show "Convirtiendo video a {format}..."
    - Download video file
    - Use FormatConverter to convert
    - Send converted video
    - Edit message to confirm

    For audio extraction:
    - Edit message to show "Extrayendo audio como {format}..."
    - Download video file
    - Use AudioExtractor to extract audio
    - Send extracted audio
    - Edit message to confirm

    Reuse existing processing logic from `handle_convert_command` and `handle_extract_audio_command` but adapt to work with stored file_id from context.

    Place this handler after handle_video_menu_callback.

    IMPORTANT: Always call `await query.answer()` at the start. Clean up context.user_data after processing.
  </action>
  <verify>grep -n "async def handle_video_format_selection" /data/data/com.termux/files/home/repos/multibot2/bot/handlers.py</verify>
  <done>Function handle_video_format_selection exists and handles video_format and video_audio_format callbacks with proper processing</done>
</task>

</tasks>

<verification>
After implementation:
1. Send a video to the bot - should show inline menu with 4 options
2. Click "Nota de Video" - should process and send video note
3. Send another video and click "Extraer Audio" - should show format options, then extract audio
4. Send another video and click "Convertir Formato" - should show format options, then convert video
5. Verify existing commands still work: /convert, /extract_audio, /split, /join
</verification>

<success_criteria>
- Video uploads trigger inline menu automatically
- Menu shows 4 options: Nota de Video, Extraer Audio, Convertir Formato, Dividir Video
- Each option routes to correct functionality
- Format selection works for both video conversion and audio extraction
- Existing video commands continue to work (/convert, /extract_audio, etc.)
- No regression in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/08-interfaz-usuario-menu-inline/08-01-SUMMARY.md`
</output>
