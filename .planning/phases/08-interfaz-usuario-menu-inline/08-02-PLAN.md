---
phase: 08-interfaz-usuario-menu-inline
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/handlers.py
autonomous: true

must_haves:
  truths:
    - "Al recibir un archivo de audio, el bot presenta automáticamente un menú inline con opciones disponibles"
    - "El menú de audio muestra opciones relevantes: voice note, convertir formato, efectos, mejora"
    - "Las selecciones del menú de audio ejecutan la funcionalidad correspondiente"
    - "Los comandos existentes de audio siguen funcionando (backward compatibility)"
  artifacts:
    - path: "bot/handlers.py"
      provides: "Audio inline menu handlers and callbacks"
      contains: ["handle_audio_menu", "handle_audio_menu_callback", "_get_audio_menu_keyboard"]
  key_links:
    - from: "handle_audio_file"
      to: "_get_audio_menu_keyboard"
      via: "inline keyboard generation"
    - from: "handle_audio_menu_callback"
      to: "existing audio handlers"
      via: "callback routing to existing logic"
---

<objective>
Implementar menú inline contextual para archivos de audio que se muestra automáticamente cuando el usuario envía un archivo de audio, permitiendo acceder a todas las funcionalidades de audio sin necesidad de comandos.

Purpose: Eliminar la necesidad de que los usuarios aprendan comandos para usar las funcionalidades de audio del bot.
Output: Handlers para mostrar menú inline de audio y procesar selecciones, integrados con la lógica existente.
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@/data/data/com.termux/files/home/repos/multibot2/bot/handlers.py
@/data/data/com.termux/files/home/repos/multibot2/bot/main.py

## Existing Audio Handlers (for reference)

The following audio handlers exist and must remain functional:
- `handle_audio_file`: Converts audio to voice note (automatic on audio upload)
- `handle_voice_message`: Converts voice message to MP3 (automatic on voice message)
- `handle_split_audio_command`: /split_audio - Splits audio
- `handle_join_audio_start/done/cancel`: /join_audio - Joins multiple audio files
- `handle_convert_audio_command`: /convert_audio - Converts audio format with inline keyboard
- `handle_bass_boost_command`: /bass_boost - Bass boost with intensity selection
- `handle_treble_boost_command`: /treble_boost - Treble boost with intensity selection
- `handle_equalize_command`: /equalize - 3-band equalizer
- `handle_denoise_command`: /denoise - Noise reduction
- `handle_compress_command`: /compress - Dynamic range compression
- `handle_normalize_command`: /normalize - Loudness normalization
- `handle_effects_command`: /effects - Effects pipeline builder

## Existing Callback Patterns

The codebase uses these callback patterns:
- `format:<format>` - Format selection (e.g., format:mp3)
- `bass:<intensity>`, `treble:<intensity>` - Intensity selection
- `eq_*` - Equalizer adjustments
- `denoise:<strength>`, `compress:<preset>` - Effect selection
- `normalize:<preset>` - Normalization preset
- `pipeline_*` - Pipeline builder
- `audio_action:<action>` - NEW pattern for audio menu

## Inline Keyboard Pattern

```python
from telegram import InlineKeyboardMarkup, InlineKeyboardButton

keyboard = [
    [InlineKeyboardButton("Text", callback_data="callback:data")],
]
reply_markup = InlineKeyboardMarkup(keyboard)
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audio inline menu keyboard generator</name>
  <files>bot/handlers.py</files>
  <action>
    Add a new function `_get_audio_menu_keyboard()` that generates an InlineKeyboardMarkup with audio action options.

    The keyboard should have 3 rows:
    - Row 1: ["Nota de Voz", "Convertir Formato"]
    - Row 2: ["Bass Boost", "Treble Boost", "Ecualizar"]
    - Row 3: ["Reducir Ruido", "Comprimir", "Normalizar"]
    - Row 4: ["Pipeline de Efectos"]

    Use callback_data pattern: `audio_action:<action>` where action is one of:
    - `voicenote` - Convert to voice note
    - `convert` - Convert audio format
    - `bass_boost` - Bass boost enhancement
    - `treble_boost` - Treble boost enhancement
    - `equalize` - 3-band equalizer
    - `denoise` - Noise reduction
    - `compress` - Dynamic range compression
    - `normalize` - Loudness normalization
    - `effects` - Effects pipeline builder

    Example implementation:
    ```python
def _get_audio_menu_keyboard() -> InlineKeyboardMarkup:
    """Generate inline keyboard for audio menu options."""
    keyboard = [
        [
            InlineKeyboardButton("Nota de Voz", callback_data="audio_action:voicenote"),
            InlineKeyboardButton("Convertir Formato", callback_data="audio_action:convert"),
        ],
        [
            InlineKeyboardButton("Bass Boost", callback_data="audio_action:bass_boost"),
            InlineKeyboardButton("Treble Boost", callback_data="audio_action:treble_boost"),
            InlineKeyboardButton("Ecualizar", callback_data="audio_action:equalize"),
        ],
        [
            InlineKeyboardButton("Reducir Ruido", callback_data="audio_action:denoise"),
            InlineKeyboardButton("Comprimir", callback_data="audio_action:compress"),
            InlineKeyboardButton("Normalizar", callback_data="audio_action:normalize"),
        ],
        [
            InlineKeyboardButton("Pipeline de Efectos", callback_data="audio_action:effects"),
        ],
    ]
    return InlineKeyboardMarkup(keyboard)
    ```

    Place this function near other keyboard generators in the file (after `_get_video_menu_keyboard` from plan 08-01).
  </action>
  <verify>grep -n "_get_audio_menu_keyboard" /data/data/com.termux/files/home/repos/multibot2/bot/handlers.py</verify>
  <done>Function `_get_audio_menu_keyboard` exists and returns InlineKeyboardMarkup with 9 audio action buttons in 4 rows</done>
</task>

<task type="auto">
  <name>Task 2: Modify handle_audio_file to show inline menu</name>
  <files>bot/handlers.py</files>
  <action>
    Modify the `handle_audio_file` function (currently around line 1876) to show an inline menu instead of automatically processing the audio to voice note.

    Changes needed:
    1. Store the audio file_id in context.user_data with key `audio_menu_file_id`
    2. Store correlation_id in context.user_data with key `audio_menu_correlation_id`
    3. Instead of processing to voice note immediately, send a message with the inline keyboard
    4. The message should say: "Audio recibido. Selecciona una acción:"
    5. Include the inline keyboard from `_get_audio_menu_keyboard()`

    The validation logic (file size check) should remain at the beginning.
    Remove or modify the processing block - voice note conversion will be handled by the callback handler.

    Example structure:
    ```python
async def handle_audio_file(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # ... existing validation code ...

    # Store file info for callback handler
    context.user_data["audio_menu_file_id"] = audio.file_id
    context.user_data["audio_menu_correlation_id"] = correlation_id

    # Show inline menu
    reply_markup = _get_audio_menu_keyboard()
    await update.message.reply_text(
        "Audio recibido. Selecciona una acción:",
        reply_markup=reply_markup
    )
    ```

    IMPORTANT: Keep all the existing validation (file size, etc.) at the beginning of the function.
    The existing voice note processing logic should be moved or adapted for the callback handler.
  </action>
  <verify>grep -A 30 "async def handle_audio_file" /data/data/com.termux/files/home/repos/multibot2/bot/handlers.py | grep -E "audio_menu_file_id|audio_menu_correlation_id|_get_audio_menu_keyboard"</verify>
  <done>handle_audio_file stores file_id and correlation_id in context.user_data and shows inline menu with _get_audio_menu_keyboard()</done>
</task>

<task type="auto">
  <name>Task 3: Create audio menu callback handler</name>
  <files>bot/handlers.py</files>
  <action>
    Create a new async function `handle_audio_menu_callback(update: Update, context: ContextTypes.DEFAULT_TYPE)` that handles audio menu selections.

    The handler should:
    1. Parse callback data (format: `audio_action:<action>`)
    2. Retrieve file_id from context.user_data["audio_menu_file_id"]
    3. Route to appropriate action by calling existing handlers or reusing their logic:

    For `voicenote` action:
    - Call `query.edit_message_text("Convirtiendo a nota de voz...")`
    - Download audio file
    - Convert to OGG Opus format using VoiceNoteConverter
    - Send as voice note
    - Edit message to confirm

    For `convert` action:
    - Store action in context.user_data["audio_menu_action"] = "convert"
    - Show format selection keyboard (reuse existing format selection or create new)
    - Use callback pattern: `audio_menu_format:<format>`

    For `bass_boost`, `treble_boost`, `equalize` actions:
    - Store file_id in appropriate context keys for existing handlers
    - Call existing handler logic or redirect to existing handlers
    - For bass/treble: use `enhance_audio_file_id`, `enhance_audio_correlation_id`, `enhance_type`
    - For equalize: use `eq_file_id`, `eq_correlation_id`

    For `denoise`, `compress`, `normalize` actions:
    - Store file_id in `effect_audio_file_id`, `effect_audio_correlation_id`
    - Store effect_type appropriately
    - Show corresponding selection keyboards (reuse existing handlers)

    For `effects` action:
    - Store file_id in `pipeline_file_id`, `pipeline_correlation_id`
    - Initialize `pipeline_effects` as empty list
    - Show pipeline builder keyboard using `_get_pipeline_keyboard([])`

    Place this handler after `handle_video_format_selection` from plan 08-01.

    IMPORTANT: Always call `await query.answer()` at the start. Clean up context.user_data keys after processing.
  </action>
  <verify>grep -n "async def handle_audio_menu_callback" /data/data/com.termux/files/home/repos/multibot2/bot/handlers.py</verify>
  <done>Function handle_audio_menu_callback exists and handles audio_action callbacks with routing to all 9 audio actions</done>
</task>

<task type="auto">
  <name>Task 4: Create audio format selection callback handler for menu</name>
  <files>bot/handlers.py</files>
  <action>
    Create a new async function `handle_audio_menu_format_selection(update: Update, context: ContextTypes.DEFAULT_TYPE)` that handles audio format selection from the inline menu.

    Callback pattern to handle:
    - `audio_menu_format:<format>` - For audio format conversion (mp3, wav, ogg, aac, flac)

    The handler should:
    1. Parse callback data to extract format
    2. Retrieve file_id from context.user_data["audio_menu_file_id"]
    3. Edit message to show "Convirtiendo audio a {format}..."
    4. Download audio file
    5. Use AudioFormatConverter to convert
    6. Send converted audio
    7. Edit message to confirm

    Reuse existing processing logic from `handle_format_selection` but adapt to work with stored file_id from context.

    IMPORTANT: This is specifically for the menu flow. The existing `handle_format_selection` handles the /convert_audio command flow.

    Place this handler after handle_audio_menu_callback.

    Always call `await query.answer()` at the start. Clean up context.user_data after processing.
  </action>
  <verify>grep -n "async def handle_audio_menu_format_selection" /data/data/com.termux/files/home/repos/multibot2/bot/handlers.py</verify>
  <done>Function handle_audio_menu_format_selection exists and handles audio_menu_format callbacks with proper conversion processing</done>
</task>

</tasks>

<verification>
After implementation:
1. Send an audio file to the bot - should show inline menu with 9 options
2. Click "Nota de Voz" - should convert and send voice note
3. Send another audio and click "Convertir Formato" - should show format options, then convert
4. Send another audio and click "Bass Boost" - should show intensity options, then apply effect
5. Send another audio and click "Pipeline de Efectos" - should show pipeline builder
6. Verify existing commands still work: /convert_audio, /bass_boost, /equalize, /effects, etc.
</verification>

<success_criteria>
- Audio file uploads trigger inline menu automatically
- Menu shows 9 options: Nota de Voz, Convertir Formato, Bass Boost, Treble Boost, Ecualizar, Reducir Ruido, Comprimir, Normalizar, Pipeline de Efectos
- Each option routes to correct functionality
- Format selection works for audio conversion
- Effect selections (intensity, presets) work correctly
- Existing audio commands continue to work
- No regression in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/08-interfaz-usuario-menu-inline/08-02-SUMMARY.md`
</output>
