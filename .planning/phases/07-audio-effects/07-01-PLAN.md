---
phase: 07-audio-effects
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/audio_effects.py
  - bot/error_handler.py
autonomous: true

must_haves:
  truths:
    - "AudioEffects class exists with denoise, compress, and normalize methods"
    - "Denoise uses ffmpeg afftdn filter with configurable noise reduction strength"
    - "Compress uses ffmpeg acompressor filter with adjustable ratio and threshold"
    - "Normalize uses ffmpeg loudnorm filter for EBU R128 loudness normalization"
    - "Effect parameters are validated and clamped to safe ranges"
    - "AudioEffectsError exception exists with Spanish error message"
    - "Effects can be chained in pipeline (method returns self for fluent interface)"
  artifacts:
    - path: "bot/audio_effects.py"
      provides: "AudioEffects class with denoise, compress, normalize methods"
      min_lines: 250
    - path: "bot/error_handler.py"
      provides: "AudioEffectsError exception class"
      contains: "class AudioEffectsError"
  key_links:
    - from: "bot/audio_effects.py"
      to: "bot/error_handler.py"
      via: "import AudioEffectsError"
      pattern: "from bot.error_handler import AudioEffectsError"
    - from: "AudioEffects.denoise"
      to: "ffmpeg subprocess"
      via: "subprocess.run with afftdn filter"
      pattern: "afftdn.*nr"
    - from: "AudioEffects.compress"
      to: "ffmpeg subprocess"
      via: "subprocess.run with acompressor filter"
      pattern: "acompressor.*ratio"
    - from: "AudioEffects.normalize"
      to: "ffmpeg subprocess"
      via: "subprocess.run with loudnorm filter"
      pattern: "loudnorm"
---

<objective>
Create AudioEffects class with professional audio effects: noise reduction (denoise), dynamic range compression (compress), and loudness normalization (normalize) using ffmpeg filters.

Purpose: Provide the core audio effects infrastructure for Phase 7, enabling users to apply professional audio processing effects with adjustable parameters.
Output: bot/audio_effects.py with AudioEffects class and AudioEffectsError in error_handler.py
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@/data/data/com.termux/files/home/repos/multibot2/bot/audio_enhancer.py
@/data/data/com.termux/files/home/repos/multibot2/bot/error_handler.py
@/data/data/com.termux/files/home/repos/multibot2/bot/audio_format_converter.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AudioEffectsError exception</name>
  <files>bot/error_handler.py</files>
  <action>
    Add AudioEffectsError exception class to error_handler.py following the existing pattern:
    - Inherit from VideoProcessingError
    - Default Spanish message: "Error aplicando efecto de audio"
    - Add to ERROR_MESSAGES dict with user-friendly message: "No pude aplicar el efecto de audio. Verifica que el archivo sea v√°lido."
    Follow the exact same pattern as AudioEnhancementError (lines 130-136).
  </action>
  <verify>grep -n "class AudioEffectsError" bot/error_handler.py</verify>
  <done>AudioEffectsError class exists with proper inheritance and Spanish error message</done>
</task>

<task type="auto">
  <name>Task 2: Create AudioEffects class with denoise method</name>
  <files>bot/audio_effects.py</files>
  <action>
    Create bot/audio_effects.py with AudioEffects class:

    1. Class structure following AudioEnhancer pattern:
       - __init__(self, input_path: str, output_path: str)
       - _check_ffmpeg() static method
       - Input/output path validation
       - Support for chained effects (intermediate output handling)

    2. denoise(strength: float = 5.0) -> "AudioEffects" method:
       - strength range: 1.0 to 10.0 (clamped)
       - Use ffmpeg afftdn (FFT Denoiser) filter for noise reduction
       - Filter syntax: afftdn=nf={noise_floor}:nr={noise_reduction}
       - Map strength (1-10) to nr parameter (0.01 to 0.5, higher = more reduction)
       - Optional: nf=-70 (noise floor in dB)
       - Example: -af "afftdn=nf=-70:nr=0.2"
       - Return self to enable method chaining

    3. Error handling:
       - Raise AudioEffectsError on failure
       - Spanish error messages for user-facing errors
       - English logging for debugging

    4. Include module-level docstring and __all__ exports.
  </action>
  <verify>python -c "from bot.audio_effects import AudioEffects; print('Import OK')"</verify>
  <done>AudioEffects class exists with denoise method, imports work</done>
</task>

<task type="auto">
  <name>Task 3: Add compress and normalize methods</name>
  <files>bot/audio_effects.py</files>
  <action>
    Add compress and normalize methods to AudioEffects class:

    1. compress(ratio: float = 4.0, threshold: float = -20.0) -> "AudioEffects" method:
       - ratio range: 1.0 to 20.0 (clamped), default 4.0
       - threshold range: -60.0 to 0.0 dB (clamped), default -20.0
       - Use ffmpeg acompressor filter for dynamic range compression
       - Filter syntax: acompressor=threshold={t}dB:ratio={r}:attack=5:release=100
       - attack=5ms, release=100ms (reasonable defaults)
       - Example: -af "acompressor=threshold=-20dB:ratio=4:attack=5:release=100"
       - Return self for method chaining

    2. normalize(target_lufs: float = -14.0) -> "AudioEffects" method:
       - target_lufs range: -23.0 to -5.0 (clamped), default -14.0
       - Use ffmpeg loudnorm filter for EBU R128 loudness normalization
       - Filter syntax: loudnorm=I={target}:TP=-1:LRA=11
       - I = integrated loudness (target LUFS)
       - TP = true peak limit (-1dB to prevent clipping)
       - LRA = loudness range (11 for general audio)
       - Example: -af "loudnorm=I=-14:TP=-1:LRA=11"
       - Return self for method chaining

    3. Pipeline support:
       - Each method returns self to enable chaining: effects.denoise().compress().normalize()
       - Track if input is original or from previous effect in chain
       - Handle intermediate file cleanup

    4. Validation:
       - Clamp all parameters to valid ranges
       - Log actual values applied
  </action>
  <verify>grep -n "def compress\|def normalize" bot/audio_effects.py && python -c "from bot.audio_effects import AudioEffects; a = AudioEffects('/tmp/test.mp3', '/tmp/out.mp3'); print('compress:', hasattr(a, 'compress'), 'normalize:', hasattr(a, 'normalize'))"</verify>
  <done>compress and normalize methods exist with parameter validation, return self for chaining</done>
</task>

</tasks>

<verification>
1. All imports work: from bot.audio_effects import AudioEffects
2. AudioEffects has methods: denoise, compress, normalize
3. AudioEffectsError exists in error_handler.py
4. Each method has proper parameter validation
5. Methods return self for chaining: effects.denoise().compress().normalize()
6. ffmpeg filter syntax is correct for afftdn, acompressor, and loudnorm
</verification>

<success_criteria>
- AudioEffects class exists in bot/audio_effects.py with 3 methods
- AudioEffectsError added to bot/error_handler.py
- denoise uses ffmpeg afftdn filter with strength 1-10 mapping to nr parameter
- compress uses ffmpeg acompressor filter with configurable ratio and threshold
- normalize uses ffmpeg loudnorm filter with configurable target LUFS
- All methods validate parameters and raise AudioEffectsError on failure
- All methods return self to enable effect pipeline chaining
- Code follows existing patterns from audio_enhancer.py
</success_criteria>

<output>
After completion, create `.planning/phases/07-audio-effects/07-01-SUMMARY.md`
</output>
