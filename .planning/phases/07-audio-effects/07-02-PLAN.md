---
phase: 07-audio-effects
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - bot/handlers.py
  - bot/main.py
autonomous: true

must_haves:
  truths:
    - "User can send /denoise command and see strength selection keyboard"
    - "User can send /compress command and see ratio selection keyboard"
    - "Denoise strength uses inline keyboard with levels 1-10"
    - "Compress ratio uses inline keyboard with presets (Light, Medium, Heavy, Extreme)"
    - "Callback handlers process denoise/compress with selected parameters"
    - "Processed audio is sent back to user with confirmation message"
    - "Help text includes /denoise and /compress commands"
  artifacts:
    - path: "bot/handlers.py"
      provides: "handle_denoise_command, handle_compress_command, and effect selection handlers"
      contains: ["def handle_denoise_command", "def handle_compress_command", "def handle_effect_selection"]
    - path: "bot/main.py"
      provides: "Handler registration for denoise and compress commands"
      contains: ["denoise", "compress", "CallbackQueryHandler.*effect"]
  key_links:
    - from: "bot/handlers.py"
      to: "bot/audio_effects.py"
      via: "import AudioEffects"
      pattern: "from bot.audio_effects import AudioEffects"
    - from: "bot/handlers.py"
      to: "bot/error_handler.py"
      via: "import AudioEffectsError"
      pattern: "from bot.error_handler import.*AudioEffectsError"
    - from: "handle_denoise_command"
      to: "inline keyboard"
      via: "InlineKeyboardMarkup with strength buttons"
      pattern: "callback_data=\"denoise:\\d+\""
    - from: "handle_compress_command"
      to: "inline keyboard"
      via: "InlineKeyboardMarkup with ratio buttons"
      pattern: "callback_data=\"compress:\\w+\""
---

<objective>
Implement /denoise and /compress commands with inline keyboard parameter selection for audio effects processing.

Purpose: Provide user-facing commands to apply noise reduction and dynamic range compression to audio files with adjustable parameters.
Output: Command handlers in handlers.py and registration in main.py with inline keyboard UI
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@/data/data/com.termux/files/home/repos/multibot2/bot/handlers.py
@/data/data/com.termux/files/home/repos/multibot2/bot/main.py
@/data/data/com.termux/files/home/repos/multibot2/bot/audio_effects.py

Reference patterns from:
- handle_bass_boost_command (line ~2400+) for command structure
- handle_intensity_selection for callback handling
- Inline keyboard pattern: 5 buttons per row for denoise
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement /denoise command handler</name>
  <files>bot/handlers.py</files>
  <action>
    Add handle_denoise_command function to handlers.py:

    1. Function signature: async def handle_denoise_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None

    2. Input validation (follow handle_bass_boost_command pattern):
       - Get audio from message or reply using _get_audio_from_message helper
       - If no audio, reply: "Envía /denoise respondiendo a un archivo de audio o adjunta el audio al mensaje."
       - Validate file size using validate_file_size

    3. Store state in context.user_data:
       - "effect_audio_file_id": audio.file_id
       - "effect_audio_correlation_id": correlation_id
       - "effect_type": "denoise"

    4. Create inline keyboard for strength selection (levels 1-10):
       - Layout: 5 buttons per row (2 rows: 1-5, 6-10)
       - Callback data format: "denoise:1", "denoise:2", etc.
       - Button text: "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"

    5. Send message: "Selecciona la intensidad de reducción de ruido (1-10):\n\n1 = Reducción ligera\n10 = Reducción máxima"

    6. Import AudioEffects and AudioEffectsError at top of file
  </action>
  <verify>grep -n "def handle_denoise_command" bot/handlers.py</verify>
  <done>handle_denoise_command exists with strength keyboard, proper validation, and state storage</done>
</task>

<task type="auto">
  <name>Task 2: Implement /compress command handler</name>
  <files>bot/handlers.py</files>
  <action>
    Add handle_compress_command function to handlers.py:

    1. Function signature: async def handle_compress_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None

    2. Input validation (same pattern as denoise):
       - Get audio from message or reply
       - Validate file size
       - Store state with "effect_type": "compress"

    3. Create inline keyboard for compression ratio presets:
       - Layout: 2 buttons per row (2 rows)
       - Callback data format: "compress:light", "compress:medium", "compress:heavy", "compress:extreme"
       - Button text and mappings:
         * "light" -> ratio 2.0 (Compresión ligera)
         * "medium" -> ratio 4.0 (Compresión media)
         * "heavy" -> ratio 8.0 (Compresión fuerte)
         * "extreme" -> ratio 12.0 (Compresión extrema)

    4. Send message: "Selecciona el nivel de compresión:\n\nCompresión reduce la diferencia entre sonidos fuertes y débiles."

    5. Both handlers should share the same state keys for file_id and correlation_id
       (user can only have one effect session at a time)
  </action>
  <verify>grep -n "def handle_compress_command" bot/handlers.py</verify>
  <done>handle_compress_command exists with ratio presets keyboard, mirroring denoise pattern</done>
</task>

<task type="auto">
  <name>Task 3: Implement effect selection callback handler</name>
  <files>bot/handlers.py</files>
  <action>
    Add handle_effect_selection function to handlers.py:

    1. Function signature: async def handle_effect_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None

    2. Parse callback data:
       - Format: "denoise:5" or "compress:medium"
       - Split by ":" to get effect_type and parameter
       - For denoise: validate parameter is 1-10 integer
       - For compress: map preset to ratio value (light=2.0, medium=4.0, heavy=8.0, extreme=12.0)

    3. Retrieve state from context.user_data:
       - file_id, correlation_id, effect_type
       - Verify effect_type matches callback prefix

    4. Processing flow (follow handle_intensity_selection pattern):
       - Update message to show processing: "Aplicando reducción de ruido (intensidad {strength})..." or "Aplicando compresión ({preset})..."
       - Use TempManager for automatic cleanup
       - Download audio file with _download_with_retry
       - Validate audio with validate_audio_file
       - Check disk space with check_disk_space

    5. Apply effect:
       - Create AudioEffects instance
       - For denoise: call denoise(strength)
       - For compress: call compress(ratio=ratio, threshold=-20.0)
       - On success: send processed audio document
       - On error: raise AudioEffectsError

    6. Success messages:
       - Denoise: "¡Listo! Reducción de ruido aplicada (intensidad {strength}/10)."
       - Compress: "¡Listo! Compresión aplicada (nivel: {preset})."

    7. Error handling:
       - Catch AudioEffectsError, ValidationError, DownloadError
       - Use handle_processing_error for consistent error messages
  </action>
  <verify>grep -n "def handle_effect_selection" bot/handlers.py</verify>
  <done>handle_effect_selection callback handler exists with full processing flow for denoise and compress</done>
</task>

<task type="auto">
  <name>Task 4: Register handlers and update help text</name>
  <files>bot/main.py, bot/handlers.py</files>
  <action>
    1. In bot/main.py:
       - Import handle_denoise_command, handle_compress_command, handle_effect_selection
       - Add CommandHandler("denoise", handle_denoise_command)
       - Add CommandHandler("compress", handle_compress_command)
       - Add CallbackQueryHandler(handle_effect_selection, pattern="^(denoise|compress):")
       - Place handlers in appropriate order (after equalize handlers)

    2. In bot/handlers.py (help text):
       - Add to help_text: "/denoise - Reduce el ruido de fondo del audio (intensidad ajustable)"
       - Add to help_text: "/compress - Comprime el rango dinámico del audio (nivel ajustable)"
       - Place after /equalize in the list
  </action>
  <verify>grep -n "denoise\|compress" bot/main.py bot/handlers.py | head -20</verify>
  <done>Handlers registered in main.py, help text updated with new commands</done>
</task>

</tasks>

<verification>
1. /denoise command shows inline keyboard with strength 1-10
2. /compress command shows inline keyboard with ratio presets (light/medium/heavy/extreme)
3. Selecting strength/preset applies the effect and sends processed audio
4. Help text includes both commands
5. Error handling works for invalid files
</verification>

<success_criteria>
- handle_denoise_command exists and shows strength keyboard (1-10)
- handle_compress_command exists and shows ratio preset keyboard
- handle_effect_selection processes callbacks and applies effects
- Callback pattern "^(denoise|compress):" properly registered
- Both commands listed in help text
- Handlers follow existing patterns from audio enhancement
- AudioEffects integration works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/07-audio-effects/07-02-SUMMARY.md`
</output>
