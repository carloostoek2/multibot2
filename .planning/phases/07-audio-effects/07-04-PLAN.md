---
phase: 07-audio-effects
plan: 04
type: execute
wave: 3
depends_on: ["07-02", "07-03"]
files_modified:
  - bot/handlers.py
  - bot/main.py
autonomous: true

must_haves:
  truths:
    - "User can send /effects command to access effect pipeline builder"
    - "Pipeline builder allows selecting multiple effects in sequence"
    - "User can configure parameters for each selected effect"
    - "Effects are applied in chain order (e.g., denoise → compress → normalize)"
    - "Pipeline preview shows selected effects and their order"
    - "User can apply or cancel the pipeline"
    - "Help text includes /effects command"
  artifacts:
    - path: "bot/handlers.py"
      provides: "handle_effects_command and handle_pipeline_builder handlers"
      contains: ["def handle_effects_command", "def handle_pipeline_builder", "def handle_pipeline_apply"]
    - path: "bot/main.py"
      provides: "Handler registration for effects pipeline command"
      contains: ["effects", "CallbackQueryHandler.*pipeline"]
  key_links:
    - from: "bot/handlers.py"
      to: "bot/audio_effects.py"
      via: "import AudioEffects"
      pattern: "from bot.audio_effects import AudioEffects"
    - from: "handle_effects_command"
      to: "inline keyboard"
      via: "InlineKeyboardMarkup with effect selection buttons"
      pattern: "callback_data=\"pipeline_(add|remove|apply|cancel)"
    - from: "handle_pipeline_apply"
      to: "AudioEffects method chaining"
      via: "effects.denoise().compress().normalize()"
      pattern: "\.denoise\(.*\)\.compress\(.*\)\.normalize"
---

<objective>
Implement /effects command with interactive pipeline builder for chaining multiple audio effects (denoise → compress → normalize).

Purpose: Allow users to combine multiple audio effects in a single processing pass, applying them in optimal order for professional audio processing workflows.
Output: Effect pipeline command with interactive builder UI
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@/data/data/com.termux/files/home/repos/multibot2/bot/handlers.py
@/data/data/com.termux/files/home/repos/multibot2/bot/main.py
@/data/data/com.termux/files/home/repos/multibot2/bot/audio_effects.py

Reference patterns:
- handle_equalize_command for multi-step interactive interface
- handle_equalizer_adjustment for state management
- AudioEffects method chaining from 07-01
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement /effects command and pipeline builder</name>
  <files>bot/handlers.py</files>
  <action>
    Add handle_effects_command function to handlers.py:

    1. Function signature: async def handle_effects_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None

    2. Input validation (follow existing pattern):
       - Get audio from message or reply using _get_audio_from_message
       - If no audio: "Envía /effects respondiendo a un archivo de audio o adjunta el audio al mensaje."
       - Validate file size

    3. Initialize pipeline state in context.user_data:
       - "pipeline_file_id": audio.file_id
       - "pipeline_correlation_id": correlation_id
       - "pipeline_effects": [] (list of effect configs)
       - Each effect config: {"type": "denoise|compress|normalize", "params": {...}}

    4. Create inline keyboard layout for pipeline builder:
       ```
       [+ Denoise] [+ Compress] [+ Normalize]  (add effects)
       [Ver Pipeline]                           (preview current)
       [Aplicar] [Cancelar]                     (action buttons)
       ```
       - Callback data: "pipeline_add:denoise", "pipeline_add:compress", "pipeline_add:normalize"
       - "pipeline_preview", "pipeline_apply", "pipeline_cancel"

    5. Display current pipeline in message:
       "Constructor de efectos de audio:\n\nEfectos en pipeline: (ninguno)\n\nAgrega efectos en el orden que deseas aplicarlos.\nOrden recomendado: Denoise → Compress → Normalize"

    6. Helper function _get_pipeline_keyboard(pipeline_effects) to generate keyboard
  </action>
  <verify>grep -n "def handle_effects_command" bot/handlers.py</verify>
  <done>handle_effects_command exists with pipeline builder keyboard and state initialization</done>
</task>

<task type="auto">
  <name>Task 2: Implement pipeline builder callback handler</name>
  <files>bot/handlers.py</files>
  <action>
    Add handle_pipeline_builder function to handlers.py:

    1. Function signature: async def handle_pipeline_builder(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None

    2. Register with pattern: "^pipeline_"

    3. Handle "pipeline_add:{effect}" callbacks:
       - Parse effect type (denoise, compress, normalize)
       - Show parameter selection for the effect:
         * Denoise: strength 1-10 (use same keyboard as /denoise)
         * Compress: ratio presets (use same mapping as /compress)
         * Normalize: preset selection (use same mapping as /normalize)
       - Store selected effect with parameters in pipeline_effects list
       - Update message to show current pipeline

    4. Handle "pipeline_remove:{index}" callback (optional - for removing effects):
       - Remove effect at index from pipeline_effects
       - Update message

    5. Handle "pipeline_preview" callback:
       - Show current pipeline as formatted list:
         ```
         Pipeline actual:
         1. Denoise (intensidad: 5)
         2. Compress (ratio: medio)
         3. Normalize (perfil: música)
         ```

    6. Handle "pipeline_cancel" callback:
       - Clear all pipeline state
       - Edit message: "Pipeline cancelado."

    7. Message format for builder:
       ```
       Constructor de efectos de audio:

       Pipeline (3 efectos):
       1. Denoise (intensidad: 5)
       2. Compress (ratio: medio)
       3. Normalize (perfil: música)

       Agrega más efectos o aplica el pipeline.
       ```
  </action>
  <verify>grep -n "def handle_pipeline_builder" bot/handlers.py</verify>
  <done>handle_pipeline_builder exists with add/preview/cancel logic and state management</done>
</task>

<task type="auto">
  <name>Task 3: Implement pipeline apply functionality</name>
  <files>bot/handlers.py</files>
  <action>
    Add pipeline apply logic to handle_pipeline_builder (when callback is "pipeline_apply"):

    1. Retrieve state:
       - file_id, correlation_id from context.user_data
       - pipeline_effects list

    2. Validate pipeline:
       - Check if pipeline has at least 1 effect
       - If empty: notify "No has agregado efectos. Agrega al menos uno antes de aplicar."

    3. Processing flow:
       - Update message: "Aplicando pipeline ({N} efectos)..."
       - Use TempManager for cleanup
       - Download audio with _download_with_retry
       - Validate with validate_audio_file
       - Check disk space (estimate based on number of effects)

    4. Apply effects in chain using AudioEffects:
       - Create AudioEffects instance with input/output paths
       - Build method chain based on pipeline_effects order
       - Example chain: effects.denoise(5).compress(4.0).normalize(-14.0)
       - Execute the chain

    5. Success:
       - Send audio document
       - Edit message to: "¡Listo! Pipeline aplicado ({N} efectos):\n{effect list}"
       - Clear context.user_data pipeline keys

    6. Error handling:
       - Catch AudioEffectsError, ValidationError, DownloadError
       - Use handle_processing_error
       - On error, keep state so user can retry

    7. Optimization:
       - Effects are applied in the order user specified
       - Method chaining ensures single ffmpeg execution where possible
  </action>
  <verify>grep -A 30 "pipeline_apply" bot/handlers.py | grep -E "denoise|compress|normalize|Aplicando|Listo"</verify>
  <done>Pipeline apply logic chains AudioEffects methods and processes audio</done>
</task>

<task type="auto">
  <name>Task 4: Register handlers and update help text</name>
  <files>bot/main.py, bot/handlers.py</files>
  <action>
    1. In bot/main.py:
       - Import handle_effects_command, handle_pipeline_builder
       - Add CommandHandler("effects", handle_effects_command)
       - Add CallbackQueryHandler(handle_pipeline_builder, pattern="^pipeline_")
       - Place after normalize handlers

    2. In bot/handlers.py (help text):
       - Add to help_text: "/effects - Aplica múltiples efectos en cadena (pipeline)"
       - Place after /normalize in the list
  </action>
  <verify>grep -n "effects" bot/main.py bot/handlers.py | head -15</verify>
  <done>Effects handlers registered, help text updated with /effects command</done>
</task>

</tasks>

<verification>
1. /effects command shows pipeline builder with add/preview/apply/cancel buttons
2. Adding effects updates the pipeline display
3. Effects can be added in any order (denoise, compress, normalize)
4. Apply button chains methods and processes audio
5. Preview shows current pipeline with effect parameters
6. Cancel clears state and ends session
7. Help text includes /effects command
</verification>

<success_criteria>
- handle_effects_command exists with pipeline builder interface
- handle_pipeline_builder handles add/preview/apply/cancel callbacks
- Pipeline state stored in context.user_data with "pipeline_" prefix
- Effects can be added with their respective parameters
- Apply button executes AudioEffects method chain
- Pipeline preview shows effect list with parameters
- Command listed in help text
- AudioEffects method chaining works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/07-audio-effects/07-04-SUMMARY.md`
</output>
