---
phase: 11-download-management-progress
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/downloaders/download_manager.py
  - bot/downloaders/__init__.py
autonomous: true

must_haves:
  truths:
    - Multiple downloads can run concurrently without interference
    - Each download has unique correlation ID for tracing
    - Downloads are queued when concurrent limit is reached
    - Active downloads can be tracked and queried by ID
    - Downloads can be cancelled by correlation ID
  artifacts:
    - path: bot/downloaders/download_manager.py
      provides: DownloadManager class with concurrent execution
      min_lines: 200
      exports:
        - DownloadManager
        - DownloadTask
        - DownloadStatus
    - path: bot/downloaders/__init__.py
      provides: Package exports updated
      contains: DownloadManager, DownloadTask, DownloadStatus
  key_links:
    - from: DownloadManager
      to: BaseDownloader
      via: download() method delegation
      pattern: self._downloader.download()
    - from: DownloadTask
      to: correlation_id
      via: unique ID assignment
      pattern: BaseDownloader._generate_correlation_id()
---

<objective>
Implement DownloadManager for concurrent download management with tracking and queue support.

Purpose: Enable multiple simultaneous downloads with individual tracking, correlation IDs, and fair queue scheduling.
Output: DownloadManager class with task tracking and queue management.
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bot/downloaders/base.py
@bot/downloaders/__init__.py
@bot/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DownloadManager core with concurrent execution</name>
  <files>bot/downloaders/download_manager.py</files>
  <action>
Create the DownloadManager class that manages concurrent downloads:

1. Import required modules: asyncio, logging, dataclasses, typing, datetime, enum
2. Create DownloadStatus enum with states: PENDING, DOWNLOADING, COMPLETED, FAILED, CANCELLED
3. Create DownloadTask dataclass to track individual downloads:
   - correlation_id: str (unique identifier)
   - url: str
   - status: DownloadStatus
   - downloader: BaseDownloader instance
   - options: DownloadOptions
   - result: Optional[DownloadResult]
   - error: Optional[Exception]
   - created_at: datetime
   - started_at: Optional[datetime]
   - completed_at: Optional[datetime]
   - progress: dict (stores latest progress update)

4. Create DownloadManager class:
   - __init__(max_concurrent: int = 5 from config.DOWNLOAD_MAX_CONCURRENT)
   - _active_downloads: Dict[str, DownloadTask] for in-progress downloads
   - _pending_queue: asyncio.Queue for pending downloads
   - _semaphore: asyncio.Semaphore for limiting concurrency
   - _lock: asyncio.Lock for thread-safe state access

5. Implement submit() method:
   - Accept url, downloader, options parameters
   - Generate correlation_id via BaseDownloader._generate_correlation_id()
   - Create DownloadTask with PENDING status
   - Add to pending queue
   - Return correlation_id immediately

6. Implement _process_queue() worker:
   - Run continuously in background task
   - Wait for semaphore slot
   - Pick next task from queue
   - Execute download with error handling
   - Update task status and result

7. Implement get_task(correlation_id) to retrieve task by ID
8. Implement cancel(correlation_id) to cancel pending or active download
9. Implement get_active_count(), get_pending_count() for monitoring

Use Spanish comments and docstrings to match codebase convention.
  </action>
  <verify>python -c "from bot.downloaders.download_manager import DownloadManager, DownloadTask, DownloadStatus; print('Import OK')"</verify>
  <done>DownloadManager class exists with submit(), get_task(), cancel() methods and concurrent execution via semaphore</done>
</task>

<task type="auto">
  <name>Task 2: Update package exports and integration</name>
  <files>bot/downloaders/__init__.py</files>
  <action>
Update bot/downloaders/__init__.py to export new classes:

1. Add imports at the top:
   from .download_manager import DownloadManager, DownloadTask, DownloadStatus

2. Add to __all__ list:
   - "DownloadManager"
   - "DownloadTask"
   - "DownloadStatus"

3. Ensure imports work without circular dependencies by using lazy imports if needed.

4. Verify the module loads correctly.
  </action>
  <verify>python -c "from bot.downloaders import DownloadManager, DownloadTask, DownloadStatus; print('Exports OK')"</verify>
  <done>Package exports updated, imports work correctly</done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for DownloadManager</name>
  <files>bot/downloaders/download_manager.py</files>
  <action>
Add test code at the bottom of download_manager.py in if __name__ == "__main__" block:

1. Test basic task creation and status tracking
2. Test concurrent download simulation (use mock downloader)
3. Test queue ordering (FIFO)
4. Test cancellation of pending task
5. Test get_task retrieval by correlation_id

Use asyncio.run() for async test execution.
  </action>
  <verify>python bot/downloaders/download_manager.py</verify>
  <done>Tests pass, demonstrating concurrent management and queue behavior</done>
</task>

</tasks>

<verification>
- DownloadManager can submit multiple downloads
- Each download gets unique correlation_id
- Concurrent limit is respected (max_concurrent)
- Excess downloads are queued
- Tasks can be retrieved by correlation_id
- Tasks can be cancelled
</verification>

<success_criteria>
1. DownloadManager class exists with full implementation
2. DownloadTask tracks all required fields
3. DownloadStatus enum has all states
4. Concurrent downloads work without interference
5. Queue maintains FIFO order
6. Package exports are updated
</success_criteria>

<output>
After completion, create `.planning/phases/11-download-management-progress/11-01-SUMMARY.md`
</output>
