---
phase: 11-download-management-progress
plan: 05
type: execute
wave: 3
depends_on: ["11-01", "11-02", "11-03", "11-04"]
files_modified:
  - bot/downloaders/download_facade.py
  - bot/downloaders/__init__.py
  - bot/handlers.py
autonomous: true

must_haves:
  truths:
    - Unified download API combines manager, progress, retry, and lifecycle
    - Downloads can be initiated with a single async call
    - Progress updates are automatically sent to users
    - All downloads are tracked with correlation IDs
    - Failed downloads trigger automatic retry with backoff
    - Downloads are isolated and cleaned up automatically
  artifacts:
    - path: bot/downloaders/download_facade.py
      provides: DownloadFacade unified API
      min_lines: 200
      exports:
        - DownloadFacade
        - download_url
        - DownloadConfig
    - path: bot/downloaders/__init__.py
      provides: Package exports updated
      contains: download_url convenience function
    - path: bot/handlers.py
      provides: Integration with bot handlers
      contains: URL download handler
  key_links:
    - from: DownloadFacade
      to: DownloadManager
      via: submit and track downloads
      pattern: manager.submit()
    - from: DownloadFacade
      to: ProgressTracker
      via: progress callback creation
      pattern: create_progress_callback()
    - from: DownloadFacade
      to: RetryHandler
      via: retry configuration
      pattern: retry_handler.execute()
    - from: DownloadFacade
      to: DownloadLifecycle
      via: temp isolation
      pattern: lifecycle.execute()
    - from: bot/handlers.py
      to: DownloadFacade
      via: URL message handler
      pattern: facade.download_url()
---

<objective>
Create DownloadFacade as a unified API that integrates all download management components.

Purpose: Provide a simple, single-call interface for downloading URLs that handles concurrency, progress, retry, and cleanup automatically.
Output: DownloadFacade class and download_url convenience function for bot integration.
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bot/downloaders/download_manager.py
@bot/downloaders/progress_tracker.py
@bot/downloaders/retry_handler.py
@bot/downloaders/download_lifecycle.py
@bot/downloaders/platform_router.py
@bot/downloaders/__init__.py
@bot/handlers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DownloadConfig and DownloadFacade</name>
  <files>bot/downloaders/download_facade.py</files>
  <action>
Create DownloadFacade as unified API in bot/downloaders/download_facade.py:

1. Import required modules: asyncio, logging, typing, dataclasses
2. Import all download components:
   - DownloadManager, DownloadTask, DownloadStatus
   - ProgressTracker, format_progress_message
   - RetryHandler
   - DownloadLifecycle
   - PlatformRouter, route_url
   - DownloadOptions, DownloadResult
   - BaseDownloader

3. Create DownloadConfig dataclass:
   - max_concurrent: int = 5
   - max_retries: int = 3
   - retry_delay: float = 2.0
   - progress_update_interval: float = 3.0
   - progress_min_percent: float = 5.0
   - cleanup_on_success: bool = True
   - cleanup_on_failure: bool = True
   - extract_audio: bool = False
   - preferred_quality: str = "best"

4. Create DownloadFacade class:
   - __init__(config: Optional[DownloadConfig] = None)
   - _manager: DownloadManager
   - _config: DownloadConfig
   - _router: PlatformRouter

5. Implement async download(
       url: str,
       chat_id: Optional[int] = None,
       message_func: Optional[Callable[[str], Awaitable[None]]] = None,
       config_overrides: Optional[dict] = None
   ) -> DownloadResult:
   - Route URL to appropriate downloader using PlatformRouter
   - Create DownloadOptions from config
   - Set up progress callback if message_func provided
   - Submit to DownloadManager
   - Wait for completion
   - Return result

6. Implement async download_with_progress(
       url: str,
       message_func: Callable[[str], Awaitable[None]],
       edit_message_func: Optional[Callable[[str], Awaitable[None]]] = None
   ) -> DownloadResult:
   - Enhanced version with live progress updates
   - Create ProgressTracker with throttling
   - Send initial "Descargando..." message
   - Update message with progress using edit_message_func
   - Send completion message with file info

7. Implement get_download_status(correlation_id: str) -> Optional[dict]:
   - Get current status of a download
   - Return dict with: status, progress, temp_dir, etc.

8. Implement cancel_download(correlation_id: str) -> bool:
   - Cancel a pending or active download
   - Return True if cancelled, False if not found

9. Implement get_active_downloads() -> List[dict]:
   - Return list of all active downloads
   - Include correlation_id, url, status, progress

10. Create standalone download_url() convenience function:
    - async download_url(url: str, **kwargs) -> DownloadResult
    - Creates facade instance and calls download()
    - Simple one-liner for basic usage

Use Spanish docstrings and comments to match codebase.
  </action>
  <verify>python -c "from bot.downloaders.download_facade import DownloadFacade, DownloadConfig, download_url; print('Facade imports OK')"</verify>
  <done>DownloadFacade exists with unified API and all methods</done>
</task>

<task type="auto">
  <name>Task 2: Create bot handler integration for URL downloads</name>
  <files>bot/handlers.py</files>
  <action>
Add URL download handler integration to bot/handlers.py:

1. Import at top of file:
   from bot.downloaders import (
       DownloadFacade,
       download_url,
       URLDetector,
   )
   from bot.downloaders.exceptions import (
       DownloadError,
       FileTooLargeError,
       URLValidationError,
       UnsupportedURLError,
   )

2. Create URL detector instance:
   url_detector = URLDetector()

3. Add handle_url_message() handler:
   async def handle_url_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
       """Handle messages containing URLs for download."""
       message_text = update.message.text
       chat_id = update.effective_chat.id

       # Detect URLs in message
       urls = url_detector.detect_urls(message_text)
       if not urls:
           return  # No URLs, ignore

       # Process first URL (or all if implementing multi-download)
       url = urls[0]

       # Send initial message
       status_message = await update.message.reply_text(
           "Analizando enlace...",
           quote=True
       )

       # Create facade
       facade = DownloadFacade()

       try:
           # Download with progress
           result = await facade.download_with_progress(
               url=url,
               chat_id=chat_id,
               message_func=lambda text: context.bot.send_message(chat_id, text),
               edit_message_func=lambda text: status_message.edit_text(text)
           )

           if result.success:
               # Send downloaded file
               await send_downloaded_file(update, context, result)
           else:
               await status_message.edit_text(
                   f"Error en la descarga: {result.error_message}"
               )

       except FileTooLargeError as e:
           await status_message.edit_text(e.to_user_message())
       except URLValidationError as e:
           await status_message.edit_text(e.to_user_message())
       except UnsupportedURLError as e:
           await status_message.edit_text(e.to_user_message())
       except DownloadError as e:
           await status_message.edit_text(e.to_user_message())
       except Exception as e:
           logging.error(f"Download error: {e}")
           await status_message.edit_text(
               "Ocurri√≥ un error inesperado. Por favor intenta de nuevo."
           )

4. Add send_downloaded_file() helper:
   async def send_downloaded_file(
       update: Update,
       context: ContextTypes.DEFAULT_TYPE,
       result: DownloadResult
   ):
       """Send downloaded file to user with inline menu."""
       file_path = result.file_path
       metadata = result.metadata or {}

       # Determine file type and send appropriately
       # (Video for video files, audio for audio files)
       # This will be fully implemented in Phase 12

       await update.message.reply_video(
           video=open(file_path, 'rb'),
           caption=f"Descarga completada: {metadata.get('title', 'Video')}"
       )

5. Register handler in main handler setup (if handlers are registered explicitly):
   # Add URL detection handler
   application.add_handler(MessageHandler(
       filters.TEXT & ~filters.COMMAND,
       handle_url_message
   ))

Use Spanish messages for user-facing text.
  </action>
  <verify>python -c "import bot.handlers; print('Handler integration OK')" 2>&1 | head -5</verify>
  <done>Handler integration added with URL detection and download flow</done>
</task>

<task type="auto">
  <name>Task 3: Update package exports</name>
  <files>bot/downloaders/__init__.py</files>
  <action>
Update bot/downloaders/__init__.py to export facade components:

1. Add imports:
   from .download_facade import (
       DownloadFacade,
       DownloadConfig,
       download_url,
   )

2. Add to __all__:
   - "DownloadFacade"
   - "DownloadConfig"
   - "download_url"

3. Reorganize __all__ into logical groups with comments:
   - # Base classes and types
   - # Exception hierarchy
   - # URL detection
   - # Downloader implementations
   - # Platform handlers
   - # Download management (new)
   - # Progress tracking (new)
   - # Retry handling (new)
   - # Lifecycle management (new)
   - # Unified API (new)

4. Verify no circular import issues.

5. Test full import chain:
   from bot.downloaders import *
  </action>
  <verify>python -c "from bot.downloaders import DownloadFacade, DownloadConfig, download_url; print('Facade exports OK')"</verify>
  <done>Package exports updated with facade components</done>
</task>

<task type="auto">
  <name>Task 4: Add comprehensive integration tests</name>
  <files>bot/downloaders/download_facade.py</files>
  <action>
Add test code at the bottom of download_facade.py in if __name__ == "__main__" block:

1. Test DownloadConfig creation and defaults
2. Test DownloadFacade initialization
3. Test download_url convenience function with mock:
   - Mock PlatformRouter to avoid actual downloads
   - Test successful download flow
   - Test error handling
4. Test progress callback integration:
   - Create mock message_func
   - Verify progress messages are sent
   - Verify throttling works
5. Test get_download_status and get_active_downloads
6. Test cancel_download

Use asyncio.run() for async test execution.
  </action>
  <verify>python bot/downloaders/download_facade.py</verify>
  <done>Integration tests pass, demonstrating unified API</done>
</task>

<task type="auto">
  <name>Task 5: Create usage examples and documentation</name>
  <files>bot/downloaders/download_facade.py</files>
  <action>
Add comprehensive docstring examples to download_facade.py:

1. Module-level docstring with usage examples:
   """
   Download Facade - Unified API for video downloads.

   This module provides a simple interface for downloading videos
   with automatic concurrency management, progress tracking,
   retry logic, and cleanup.

   Basic usage:
       from bot.downloaders import download_url

       result = await download_url("https://youtube.com/watch?v=...")
       if result.success:
           print(f"Downloaded: {result.file_path}")

   With progress updates:
       from bot.downloaders import DownloadFacade

       facade = DownloadFacade()
       result = await facade.download_with_progress(
           url="https://youtube.com/watch?v=...",
           message_func=lambda text: bot.send_message(chat_id, text)
       )

   Advanced configuration:
       config = DownloadConfig(
           max_concurrent=3,
           max_retries=5,
           extract_audio=True
       )
       facade = DownloadFacade(config)
   """

2. Add examples to class docstrings
3. Add examples to method docstrings
4. Document all configuration options
5. Document error handling patterns

Ensure all examples use Spanish messages for user-facing text.
  </action>
  <verify>python -c "import bot.downloaders.download_facade; help(bot.downloaders.download_facade)" | head -50</verify>
  <done>Documentation and examples added</done>
</task>

</tasks>

<verification>
- DownloadFacade can be instantiated
- download_url convenience function works
- Progress updates are sent correctly
- Downloads are tracked by correlation_id
- Handler integration receives URL messages
- Package imports work correctly
- All components work together
</verification>

<success_criteria>
1. DownloadFacade provides unified API
2. download_url convenience function works
3. Progress tracking integrated with facade
4. Retry logic applied automatically
5. Temp isolation and cleanup work
6. Handler integration routes URL messages
7. Package exports are complete
8. Documentation and examples provided
</success_criteria>

<output>
After completion, create `.planning/phases/11-download-management-progress/11-05-SUMMARY.md`
</output>
