---
phase: 11-download-management-progress
plan: 04
type: execute
wave: 2
depends_on: ["11-01", "11-03"]
files_modified:
  - bot/downloaders/download_lifecycle.py
  - bot/downloaders/download_manager.py
  - bot/downloaders/__init__.py
  - bot/temp_manager.py
autonomous: true

must_haves:
  truths:
    - Each download is isolated in separate temp directory
    - Failed downloads are cleaned up automatically
    - Temp directories use correlation_id for identification
    - Cleanup happens on success, failure, or cancellation
    - Download lifecycle events are trackable
  artifacts:
    - path: bot/downloaders/download_lifecycle.py
      provides: DownloadLifecycle with temp isolation
      min_lines: 150
      exports:
        - DownloadLifecycle
        - IsolatedDownload
        - cleanup_download
    - path: bot/downloaders/download_manager.py
      provides: Integration with lifecycle
      contains: TempManager usage per download
    - path: bot/temp_manager.py
      provides: Enhanced temp management
      contains: correlation_id support
  key_links:
    - from: DownloadLifecycle
      to: TempManager
      via: isolated temp directory creation
      pattern: TempManager.get_subdir(correlation_id)
    - from: IsolatedDownload
      to: cleanup
      via: context manager __exit__
      pattern: shutil.rmtree(temp_dir)
    - from: DownloadManager
      to: DownloadLifecycle
      via: execute_download method
      pattern: lifecycle.execute()
---

<objective>
Implement download lifecycle management with isolated temp directories and automatic cleanup.

Purpose: Ensure each download runs in isolation with proper resource cleanup on completion, failure, or cancellation.
Output: DownloadLifecycle class with temp isolation and automatic cleanup integration.
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bot/downloaders/download_manager.py
@bot/downloaders/base.py
@bot/temp_manager.py
@bot/downloaders/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DownloadLifecycle with isolated temp directories</name>
  <files>bot/downloaders/download_lifecycle.py</files>
  <action>
Create DownloadLifecycle class in bot/downloaders/download_lifecycle.py:

1. Import required modules: os, shutil, asyncio, logging, typing, contextlib, tempfile
2. Import TempManager from bot.temp_manager
3. Import DownloadOptions from bot.downloaders.base

4. Create IsolatedDownload context manager class:
   - __init__(correlation_id: str, base_temp_dir: Optional[str] = None)
   - _temp_dir: str (isolated directory for this download)
   - __enter__() -> str: Returns temp directory path, creates it
   - __exit__(exc_type, exc_val, exc_tb): Cleans up temp directory
   - cleanup(): Force cleanup of temp directory
   - get_path(filename: str) -> str: Get path within isolated directory

5. Create DownloadLifecycle class:
   - __init__(
       correlation_id: str,
       options: DownloadOptions,
       cleanup_on_success: bool = True,
       cleanup_on_failure: bool = True
     )
   - _isolated: IsolatedDownload instance
   - _state: dict tracking lifecycle state

6. Implement async execute(
       download_func: Callable[[str], Awaitable[DownloadResult]],
       progress_callback: Optional[Callable] = None
     ) -> DownloadResult:
   - Create isolated temp directory
   - Update DownloadOptions with isolated output_path
   - Execute download_func with isolated path
   - On success: cleanup if configured, return result
   - On failure: cleanup if configured, re-raise error
   - On cancellation: cleanup, raise CancelledError

7. Implement get_temp_path(filename: str) -> str:
   - Return path within isolated directory

8. Implement cleanup():
   - Force cleanup of isolated directory
   - Called automatically on context exit

9. Create standalone cleanup_download(correlation_id: str) utility:
   - Clean up temp directory for a specific download
   - Useful for manual cleanup or recovery

Use Spanish docstrings and comments to match codebase.
  </action>
  <verify>python -c "from bot.downloaders.download_lifecycle import DownloadLifecycle, IsolatedDownload; print('Lifecycle imports OK')"</verify>
  <done>DownloadLifecycle and IsolatedDownload classes exist with temp isolation</done>
</task>

<task type="auto">
  <name>Task 2: Enhance TempManager with correlation_id support</name>
  <files>bot/temp_manager.py</files>
  <action>
Enhance TempManager in bot/temp_manager.py to support correlation_id:

1. Add optional correlation_id parameter to __init__:
   - __init__(self, correlation_id: Optional[str] = None)
   - If correlation_id provided: use it in temp directory name
   - Format: videonote_{correlation_id}_{random_suffix}

2. Add get_download_temp_dir(correlation_id: str) -> str class method:
   - Create temp directory specifically for a download
   - Return path to directory
   - Format: videonote_dl_{correlation_id}

3. Add cleanup_by_correlation_id(correlation_id: str) -> bool:
   - Find and cleanup temp directory by correlation_id
   - Return True if found and cleaned, False otherwise
   - Search pattern: videonote_dl_{correlation_id}*

4. Add list_active_downloads() -> List[str]:
   - Return list of correlation_ids for active downloads
   - Scan temp directories for videonote_dl_* pattern
   - Extract correlation_ids from directory names

5. Update cleanup_old_temp_directories to handle download-specific dirs:
   - Include videonote_dl_* pattern in cleanup
   - Log correlation_id if present in directory name

Use Spanish comments for consistency.
  </action>
  <verify>python -c "from bot.temp_manager import TempManager; tm = TempManager(correlation_id='abc123'); print('TempManager with correlation_id OK')"</verify>
  <done>TempManager enhanced with correlation_id support</done>
</task>

<task type="auto">
  <name>Task 3: Integrate lifecycle with DownloadManager</name>
  <files>bot/downloaders/download_manager.py</files>
  <action>
Update DownloadManager in bot/downloaders/download_manager.py to use DownloadLifecycle:

1. Import DownloadLifecycle from .download_lifecycle

2. Update DownloadTask dataclass:
   - Add lifecycle: Optional[DownloadLifecycle] = None
   - Add temp_dir: Optional[str] = None

3. Update _process_queue() or execute method:
   - Create DownloadLifecycle instance when starting download
   - Set task.lifecycle = lifecycle
   - Set task.temp_dir = lifecycle.get_temp_path("")
   - Pass isolated output_path to downloader

4. Update download execution to use lifecycle.execute():
   - Wrap actual download in lifecycle.execute()
   - This ensures proper temp isolation and cleanup

5. Update cancel() method:
   - If task has lifecycle, call lifecycle.cleanup()
   - Ensure temp directory is removed on cancellation

6. Add get_temp_path(correlation_id: str, filename: str) -> Optional[str]:
   - Get path within download's temp directory
   - Return None if download not found

7. Update cleanup on task completion:
   - Ensure lifecycle.cleanup() is called
   - Handle any cleanup errors gracefully

Use Spanish comments for consistency.
  </action>
  <verify>python -c "from bot.downloaders.download_manager import DownloadManager; print('DownloadManager lifecycle integration OK')"</verify>
  <done>DownloadManager integrated with DownloadLifecycle</done>
</task>

<task type="auto">
  <name>Task 4: Update package exports</name>
  <files>bot/downloaders/__init__.py</files>
  <action>
Update bot/downloaders/__init__.py to export lifecycle components:

1. Add imports:
   from .download_lifecycle import (
       DownloadLifecycle,
       IsolatedDownload,
       cleanup_download,
   )

2. Add to __all__:
   - "DownloadLifecycle"
   - "IsolatedDownload"
   - "cleanup_download"

3. Verify no circular import issues with the new imports.

4. Ensure imports work correctly.
  </action>
  <verify>python -c "from bot.downloaders import DownloadLifecycle, IsolatedDownload, cleanup_download; print('Lifecycle exports OK')"</verify>
  <done>Package exports updated with lifecycle components</done>
</task>

<task type="auto">
  <name>Task 5: Add tests for download lifecycle</name>
  <files>bot/downloaders/download_lifecycle.py</files>
  <action>
Add test code at the bottom of download_lifecycle.py in if __name__ == "__main__" block:

1. Test IsolatedDownload context manager:
   - Create isolated download
   - Verify directory exists inside context
   - Verify directory is cleaned up after context exit
   - Verify cleanup on exception

2. Test DownloadLifecycle:
   - Create lifecycle with mock download function
   - Verify temp directory is used
   - Verify cleanup on success
   - Verify cleanup on failure

3. Test TempManager correlation_id support:
   - Create TempManager with correlation_id
   - Verify directory name contains correlation_id
   - Test cleanup_by_correlation_id

Use asyncio.run() for async test execution.
  </action>
  <verify>python bot/downloaders/download_lifecycle.py</verify>
  <done>Tests pass, demonstrating temp isolation and cleanup</done>
</task>

</tasks>

<verification>
- IsolatedDownload creates isolated temp directories
- Temp directories are cleaned up on context exit
- DownloadManager uses lifecycle for each download
- TempManager supports correlation_id
- Package imports work correctly
- Cleanup happens on success, failure, and cancellation
</verification>

<success_criteria>
1. IsolatedDownload context manager works correctly
2. DownloadLifecycle manages download execution with temp isolation
3. TempManager enhanced with correlation_id support
4. DownloadManager integrated with lifecycle
5. Cleanup happens automatically on all exit paths
6. Package exports are updated
</success_criteria>

<output>
After completion, create `.planning/phases/11-download-management-progress/11-04-SUMMARY.md`
</output>
