---
phase: 11-download-management-progress
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - bot/downloaders/retry_handler.py
  - bot/downloaders/exceptions.py
  - bot/downloaders/__init__.py
  - bot/downloaders/base.py
autonomous: true

must_haves:
  truths:
    - Retry logic handles transient network failures with 3 attempts
    - Rate limit detection triggers appropriate backoff
    - Stalled downloads timeout and fail gracefully
    - Exponential backoff increases delay between retries
    - Retry decisions are based on error type
  artifacts:
    - path: bot/downloaders/retry_handler.py
      provides: RetryHandler with exponential backoff
      min_lines: 150
      exports:
        - RetryHandler
        - is_retryable_error
        - RateLimitError
    - path: bot/downloaders/exceptions.py
      provides: Updated exception hierarchy
      contains: RateLimitError class
    - path: bot/downloaders/base.py
      provides: Enhanced download with retry
      contains: download_with_retry method
  key_links:
    - from: RetryHandler
      to: NetworkError
      via: error type checking
      pattern: isinstance(error, NetworkError)
    - from: RetryHandler
      to: RateLimitError
      via: rate limit detection
      pattern: "rate limit" in error_message.lower()
    - from: BaseDownloader
      to: RetryHandler
      via: download_with_retry method
      pattern: self._retry_handler.execute()
---

<objective>
Implement enhanced error handling with retry logic, rate limit detection, and timeout handling.

Purpose: Ensure downloads are resilient to transient failures, with intelligent retry decisions and proper backoff strategies.
Output: RetryHandler class, RateLimitError exception, and enhanced BaseDownloader with retry support.
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bot/downloaders/base.py
@bot/downloaders/exceptions.py
@bot/downloaders/__init__.py
@bot/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RateLimitError to exception hierarchy</name>
  <files>bot/downloaders/exceptions.py</files>
  <action>
Add RateLimitError exception class to bot/downloaders/exceptions.py:

1. Create RateLimitError class extending DownloadError:
   - Attributes:
     - retry_after: Optional[int] - seconds to wait (from platform headers if available)
     - platform: Optional[str] - platform that issued rate limit
   - __init__(
       message: str = "Rate limit exceeded",
       url: Optional[str] = None,
       correlation_id: Optional[str] = None,
       retry_after: Optional[int] = None,
       platform: Optional[str] = None
     )
   - to_user_message() -> str:
     - Return Spanish message: "Límite de descargas alcanzado. Por favor espera {retry_after} segundos."
     - If retry_after not available: "Límite de descargas alcanzado. Por favor intenta más tarde."

2. Update __all__ list to include RateLimitError

3. Add docstring explaining when this error is raised:
   - YouTube rate limiting
   - Instagram rate limiting
   - TikTok rate limiting
   - Generic HTTP 429 responses

Use Spanish user messages to match bot convention.
  </action>
  <verify>python -c "from bot.downloaders.exceptions import RateLimitError; e = RateLimitError(retry_after=60); print(e.to_user_message())"</verify>
  <done>RateLimitError exists with proper attributes and Spanish user message</done>
</task>

<task type="auto">
  <name>Task 2: Create RetryHandler with exponential backoff</name>
  <files>bot/downloaders/retry_handler.py</files>
  <action>
Create RetryHandler class in bot/downloaders/retry_handler.py:

1. Import required modules: asyncio, logging, random, typing, datetime
2. Import exceptions: NetworkError, DownloadFailedError, RateLimitError

3. Create is_retryable_error(error: Exception) -> bool:
   - Return True for: NetworkError, asyncio.TimeoutError, ConnectionError
   - Return False for: FileTooLargeError, URLValidationError, UnsupportedURLError
   - Check error messages for retry indicators:
     - "timeout", "connection", "network", "temporary", "unavailable"
   - Return False for permanent failures:
     - "not found", "forbidden", "private", "deleted", "unavailable"

4. Create RetryHandler class:
   - __init__(
       max_retries: int = 3,  # per EH-03
       base_delay: float = 2.0,
       max_delay: float = 60.0,
       exponential_base: float = 2.0,
       jitter: bool = True  # Add randomness to prevent thundering herd
     )

5. Implement calculate_delay(attempt: int, retry_after: Optional[int] = None) -> float:
   - If retry_after provided: use that value
   - Otherwise: base_delay * (exponential_base ** attempt)
   - Apply max_delay cap
   - If jitter: add random 0-1 second
   - Return calculated delay

6. Implement async execute(
       operation: Callable[[], T],
       operation_name: str = "operation",
       is_retryable: Optional[Callable[[Exception], bool]] = None
     ) -> T:
   - Try operation up to max_retries + 1 times
   - On failure: check if retryable, calculate delay, log, sleep, retry
   - On rate limit: extract retry_after if available, use longer delay
   - Return result on success
   - Raise last error after all retries exhausted
   - Log each retry attempt with correlation_id if available

7. Implement _extract_retry_after(error: Exception) -> Optional[int]:
   - Parse error messages for retry-after hints
   - Look for patterns: "retry after", "rate limit", "too many requests"
   - Extract numeric value if present

Use Spanish log messages and comments to match codebase.
  </action>
  <verify>python -c "from bot.downloaders.retry_handler import RetryHandler, is_retryable_error; from bot.downloaders.exceptions import NetworkError, FileTooLargeError; print('Network retryable:', is_retryable_error(NetworkError('test'))); print('FileTooLarge retryable:', is_retryable_error(FileTooLargeError(100, 50)))"</verify>
  <done>RetryHandler exists with exponential backoff and retryable error detection</done>
</task>

<task type="auto">
  <name>Task 3: Add download_with_retry to BaseDownloader</name>
  <files>bot/downloaders/base.py</files>
  <action>
Enhance BaseDownloader with retry support in bot/downloaders/base.py:

1. Import RetryHandler at top (use TYPE_CHECKING guard to avoid circular imports if needed)

2. Add to BaseDownloader.__init__ (if not already present):
   - self._retry_handler = RetryHandler(
       max_retries=options.max_retries if options else 3,
       base_delay=options.retry_delay if options else 2.0
     )
   - Or create retry_handler property that creates on first access

3. Add download_with_retry() method:
   async def download_with_retry(
       self,
       url: str,
       options: DownloadOptions,
       progress_callback: Optional[Callable] = None
   ) -> DownloadResult:
   """Download with automatic retry on transient failures."""
   - Create RetryHandler instance with settings from options
   - Define operation = lambda: self.download(url, options)
   - Call retry_handler.execute(operation, "download")
   - Return result

4. Add abstract method signature if needed for type checking

5. Ensure correlation_id is preserved across retries

6. Update docstrings to document retry behavior

Use Spanish comments for consistency.
  </action>
  <verify>python -c "from bot.downloaders.base import BaseDownloader; print('BaseDownloader has download_with_retry:', hasattr(BaseDownloader, 'download_with_retry'))"</verify>
  <done>BaseDownloader has download_with_retry method</done>
</task>

<task type="auto">
  <name>Task 4: Update package exports and add timeout handling</name>
  <files>bot/downloaders/__init__.py, bot/downloaders/retry_handler.py</files>
  <action>
1. Update bot/downloaders/__init__.py:
   - Add imports:
     from .retry_handler import RetryHandler, is_retryable_error
     from .exceptions import RateLimitError
   - Add to __all__:
     - "RetryHandler"
     - "is_retryable_error"
     - "RateLimitError"

2. Add timeout handling utilities to retry_handler.py:
   - Create TimeoutConfig dataclass:
     - connect_timeout: float
     - read_timeout: float
     - total_timeout: float
   - Create create_timeout_guard(total_timeout: float) -> asyncio.Timeout:
     - Context manager for enforcing total operation timeout
   - Add to RetryHandler:
     - execute_with_timeout(operation, timeout) method
     - Handles TimeoutError as retryable

3. Verify all imports work correctly.
  </action>
  <verify>python -c "from bot.downloaders import RetryHandler, is_retryable_error, RateLimitError; print('All retry imports OK')"</verify>
  <done>Package exports updated, timeout handling added</done>
</task>

<task type="auto">
  <name>Task 5: Add comprehensive tests for retry logic</name>
  <files>bot/downloaders/retry_handler.py</files>
  <action>
Add test code at the bottom of retry_handler.py in if __name__ == "__main__" block:

1. Test is_retryable_error with various exception types
2. Test RetryHandler.calculate_delay:
   - Verify exponential growth
   - Verify max_delay cap
   - Verify retry_after override
3. Test RetryHandler.execute with mock failing operation:
   - Test successful retry after failures
   - Test non-retryable error (immediate failure)
   - Test exhaustion of retries
4. Test rate limit detection

Use asyncio.run() for async test execution.
  </action>
  <verify>python bot/downloaders/retry_handler.py</verify>
  <done>Tests pass, demonstrating retry logic and backoff behavior</done>
</task>

</tasks>

<verification>
- RateLimitError exists with proper attributes
- is_retryable_error correctly classifies errors
- RetryHandler implements exponential backoff
- BaseDownloader has download_with_retry method
- Timeout handling works correctly
- Package imports work correctly
</verification>

<success_criteria>
1. RateLimitError exception class exists
2. is_retryable_error function correctly identifies retryable errors
3. RetryHandler implements exponential backoff with jitter
4. RetryHandler respects max_retries=3 per EH-03
5. BaseDownloader has download_with_retry method
6. Timeout handling guards against stalled downloads per EH-04
7. Package exports are updated
</success_criteria>

<output>
After completion, create `.planning/phases/11-download-management-progress/11-03-SUMMARY.md`
</output>
