---
phase: 09-downloader-core
plan: 04
type: execute
wave: 3
depends_on: ["09-02"]
files_modified:
  - bot/downloaders/generic_downloader.py
  - bot/downloaders/__init__.py
  - requirements.txt
autonomous: true

user_setup:
  - service: aiohttp
    why: "Async HTTP client for generic video downloads"
    install: "pip install aiohttp>=3.9.0 aiofiles>=23.0.0"
    env_vars: []

must_haves:
  truths:
    - "Generic downloader can download direct video file URLs (.mp4, .webm, .mov)"
    - "Content-Type header is validated before download (DL-05)"
    - "File size is checked from Content-Length header before streaming (QF-05)"
    - "Downloads use streaming to avoid memory issues"
    - "Progress callbacks provide real-time feedback during download"
  artifacts:
    - path: "bot/downloaders/generic_downloader.py"
      provides: "Direct HTTP video downloader"
      exports: ["GenericDownloader"]
      min_lines: 200
    - path: "requirements.txt"
      provides: "Project dependencies"
      contains: "aiohttp>=3.9.0, aiofiles>=23.0.0"
  key_links:
    - from: "bot/downloaders/generic_downloader.py"
      to: "bot/downloaders/base.py"
      via: "class inheritance"
      pattern: "class GenericDownloader(BaseDownloader)"
---

<objective>
Implement the generic HTTP downloader for direct video file URLs. This downloader uses aiohttp for async streaming downloads of .mp4, .webm, .mov files and other direct video URLs.

Purpose: Support downloading videos from any direct URL without requiring platform-specific extractors. Satisfies DL-05 (file validation), DL-07 (generic video URL support), QF-05 (file size limits), and EH-02 (clear error messages).
Output: GenericDownloader class that can download videos from direct URLs with streaming and progress tracking.
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-downloader-core/09-RESEARCH.md
@bot/downloaders/base.py
@bot/downloaders/exceptions.py
@bot/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add aiohttp dependencies</name>
  <files>requirements.txt</files>
  <action>
Ensure aiohttp and aiofiles are in the project dependencies.

Update requirements.txt to include:
```
aiohttp>=3.9.0
aiofiles>=23.0.0
```

If requirements.txt was created in Plan 03, ensure these are added:
```
# Core dependencies
python-telegram-bot>=20.0
yt-dlp>=2026.2.4
aiohttp>=3.9.0
aiofiles>=23.0.0

# Existing dependencies (preserve)
ffmpeg-python>=0.2.0
python-dotenv>=1.0.0
python-magic>=0.4.27  # Optional, for file type validation
```

aiohttp is used for async HTTP requests (lighter than httpx for this use case).
aiofiles is used for non-blocking file I/O during streaming downloads.
  </action>
  <verify>
    - requirements.txt contains aiohttp>=3.9.0 and aiofiles>=23.0.0
    - pip can parse requirements.txt without errors
    - aiohttp can be imported: python -c "import aiohttp; print(aiohttp.__version__)"
    - aiofiles can be imported: python -c "import aiofiles; print('OK')"
  </verify>
  <done>
    - aiohttp and aiofiles added to requirements.txt
    - Dependencies are installable
    - Import tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement GenericDownloader class</name>
  <files>bot/downloaders/generic_downloader.py</files>
  <action>
Create the GenericDownloader class that implements the BaseDownloader interface for direct video file URLs.

Implement:

1. **Class definition**:
   ```python
   class GenericDownloader(BaseDownloader):
       """Downloader for direct video file URLs using aiohttp."""
   ```

2. **Properties**:
   - `name = "Generic HTTP Downloader"`
   - `supported_platforms = ["Direct Video URLs"]`
   - `VIDEO_EXTENSIONS = {'.mp4', '.webm', '.mov', '.mkv', '.avi', '.flv', '.wmv'}`
   - `VIDEO_MIME_TYPES = {'video/mp4', 'video/webm', 'video/quicktime', 'video/x-msvideo', 'video/x-flv'}`

3. **can_handle(url: str) -> bool**:
   - Check if URL ends with a video extension (from VIDEO_EXTENSIONS)
   - OR check if URL is a valid HTTP/HTTPS URL (for URLs without extension)
   - Return True for any HTTP(S) URL that might be a video
   - This is a quick check; full validation happens in extract_metadata

4. **extract_metadata(url: str, options: DownloadOptions) -> dict**:
   - Make HEAD request to get headers without downloading
   - Extract metadata from response headers:
     ```python
     async with aiohttp.ClientSession() as session:
         async with session.head(url, allow_redirects=True) as response:
             response.raise_for_status()

             content_type = response.headers.get('content-type', '')
             content_length = response.headers.get('content-length')

             # Validate it's a video
             if not self._is_video_content(content_type, url):
                 raise UnsupportedURLError(f"URL does not point to a video file")

             metadata = {
                 'title': self._extract_filename_from_url(url),
                 'duration': None,  # Can't determine from headers
                 'uploader': None,
                 'thumbnail': None,
                 'filesize': int(content_length) if content_length else None,
                 'content_type': content_type,
                 'url': str(response.url),  # Final URL after redirects
             }
     ```
   - Handle redirects automatically (per GV-03)
   - Return metadata dict

5. **download(url: str, options: DownloadOptions) -> DownloadResult**:
   - Generate correlation_id for request tracing
   - Validate URL and check file size before downloading
   - Use aiohttp for streaming download (per research Pattern 4):
     ```python
     async with aiohttp.ClientSession() as session:
         async with session.get(url, timeout=aiohttp.ClientTimeout(total=options.download_timeout)) as response:
             response.raise_for_status()

             # Check content type (per DL-05)
             content_type = response.headers.get('content-type', '')
             if not self._is_video_content(content_type, url):
                 raise UnsupportedURLError("URL does not point to a video file")

             # Check file size from Content-Length header (per QF-05)
             total_size = int(response.headers.get('content-length', 0))
             if total_size > options.max_filesize:
                 raise FileTooLargeError(
                     url=url,
                     file_size=total_size,
                     max_size=options.max_filesize,
                     correlation_id=correlation_id
                 )

             # Determine output path
             output_path = self._build_output_path(url, options, content_type)

             # Stream download with progress (per research Pattern 4)
             downloaded = 0
             async with aiofiles.open(output_path, 'wb') as f:
                 async for chunk in response.content.iter_chunked(8192):
                     await f.write(chunk)
                     downloaded += len(chunk)

                     # Call progress callback
                     if options.progress_callback and total_size:
                         progress = {
                             'percent': (downloaded / total_size) * 100,
                             'downloaded_bytes': downloaded,
                             'total_bytes': total_size,
                         }
                         await options.progress_callback(progress)
     ```
   - Return DownloadResult with success status and file path

6. **Helper methods**:
   - `_is_video_content(content_type: str, url: str) -> bool` - Check if content is video
   - `_extract_filename_from_url(url: str) -> str` - Extract filename from URL path
   - `_build_output_path(url, options, content_type) -> str` - Build output file path
   - `_get_extension_from_content_type(content_type: str) -> str` - Map MIME type to extension

7. **Error handling**:
   - ClientResponseError (4xx, 5xx) -> DownloadFailedError
   - ClientConnectorError -> NetworkError
   - asyncio.TimeoutError -> DownloadFailedError with timeout message
   - Invalid URL -> URLValidationError
  </action>
  <verify>
    - GenericDownloader can be instantiated
    - can_handle returns True for .mp4 URLs
    - can_handle returns True for .webm URLs
    - extract_metadata returns metadata from headers
    - download saves file and returns DownloadResult
  </verify>
  <done>
    - GenericDownloader implements BaseDownloader interface
    - can_handle identifies direct video URLs
    - extract_metadata validates Content-Type (DL-05)
    - download uses aiohttp streaming (non-blocking)
    - Progress callbacks work during streaming
    - File size checked from Content-Length header (QF-05)
    - Redirects followed automatically (GV-03)
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement file integrity validation</name>
  <files>bot/downloaders/generic_downloader.py</files>
  <action>
Add file integrity validation after download completes (per DL-05 requirement).

After the download loop completes:

1. **Size validation**:
   ```python
   actual_size = os.path.getsize(output_path)
   if total_size and actual_size != total_size:
       raise DownloadFailedError(
           f"Download incomplete: expected {total_size} bytes, got {actual_size}",
           url=url,
           correlation_id=correlation_id
       )
   ```

2. **File type validation** (optional, if python-magic available):
   ```python
   try:
       import magic
       mime = magic.from_file(output_path, mime=True)
       if not mime.startswith('video/'):
           raise DownloadFailedError(
               f"Downloaded file is not a video (detected: {mime})",
               url=url,
               correlation_id=correlation_id
           )
   except ImportError:
       pass  # Skip if python-magic not installed
   ```

3. **Non-empty file check**:
   ```python
   if actual_size == 0:
       raise DownloadFailedError(
           "Downloaded file is empty",
           url=url,
           correlation_id=correlation_id
       )
   ```

4. **Cleanup on failure**:
   ```python
   try:
       # download logic
       pass
   except Exception:
       # Clean up partial file
       if os.path.exists(output_path):
           os.remove(output_path)
       raise
   ```

This ensures downloaded files are valid before being returned to the user.
  </action>
  <verify>
    - File size is validated after download
    - Empty files are rejected
    - Partial files are cleaned up on failure
    - python-magic validation works if available
  </verify>
  <done>
    - Size validation compares actual vs expected size
    - File type validation using python-magic (optional)
    - Non-empty file check
    - Automatic cleanup of partial files on error
  </done>
</task>

<task type="auto">
  <name>Task 4: Update package exports</name>
  <files>bot/downloaders/__init__.py</files>
  <action>
Update the downloaders package to export the GenericDownloader class.

Add to __init__.py:
```python
from .generic_downloader import GenericDownloader

__all__ = [
    # ... existing exports ...
    'GenericDownloader',
]
```

Ensure GenericDownloader can be imported directly from the package:
```python
from bot.downloaders import GenericDownloader
```

Also create a convenience function for getting the right downloader:
```python
def get_downloader_for_url(url: str) -> Optional[BaseDownloader]:
    """Get appropriate downloader for a URL.

    Returns YtDlpDownloader for platform URLs,
    GenericDownloader for direct video URLs.
    """
    # Try generic first (faster check)
    generic = GenericDownloader()
    if await generic.can_handle(url):
        return generic

    # Fall back to yt-dlp
    ytdlp = YtDlpDownloader()
    if await ytdlp.can_handle(url):
        return ytdlp

    return None
```

This function will be used by the message handler to route URLs to the appropriate downloader.
  </action>
  <verify>
    - GenericDownloader is importable from bot.downloaders
    - get_downloader_for_url function available (if added)
    - No circular import errors
    - All exports listed in __all__
  </verify>
  <done>
    - GenericDownloader exported from package
    - get_downloader_for_url helper available
    - Import test: from bot.downloaders import GenericDownloader, get_downloader_for_url
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Import test**: `python -c "from bot.downloaders import GenericDownloader; print('OK')"`
2. **Instantiation test**: Create GenericDownloader instance
3. **can_handle test**: Test with .mp4 URL (should return True)
4. **can_handle test**: Test with non-video URL (should return False)
5. **Metadata test**: Extract metadata from a direct video URL
6. **Size check test**: Verify Content-Length validation works
7. **Integration test**: Full download flow (optional, network-dependent)

Note: Actual download tests require network access and should be done manually.
</verification>

<success_criteria>
- GenericDownloader implements BaseDownloader interface correctly
- aiohttp and aiofiles dependencies added to requirements.txt
- can_handle identifies direct video URLs by extension
- extract_metadata validates Content-Type header (DL-05)
- download uses aiohttp streaming with async file I/O
- Content-Length checked before download starts (QF-05)
- Progress callbacks provide real-time feedback
- File integrity validated after download (size, non-empty)
- Partial files cleaned up on failure
- Redirects followed automatically (GV-03)
- All errors converted to appropriate custom exceptions
</success_criteria>

<output>
After completion, create `.planning/phases/09-downloader-core/09-04-SUMMARY.md`
</output>
