---
phase: 09-downloader-core
plan: 03
type: execute
wave: 3
depends_on: ["09-02"]
files_modified:
  - bot/downloaders/ytdlp_downloader.py
  - bot/downloaders/__init__.py
  - requirements.txt
autonomous: true

user_setup:
  - service: yt-dlp
    why: "Platform video downloading (YouTube, Instagram, etc.)"
    install: "pip install yt-dlp>=2026.2.4"
    env_vars: []

must_haves:
  truths:
    - "yt-dlp downloader can extract metadata from any supported platform URL"
    - "yt-dlp downloader downloads videos with format selection for Telegram compatibility"
    - "Downloads run in thread pool to avoid blocking the event loop"
    - "Progress hooks provide real-time feedback during downloads"
    - "File size is checked before download to respect Telegram limits"
  artifacts:
    - path: "bot/downloaders/ytdlp_downloader.py"
      provides: "yt-dlp based downloader implementation"
      exports: ["YtDlpDownloader"]
      min_lines: 250
    - path: "requirements.txt"
      provides: "Project dependencies"
      contains: "yt-dlp>=2026.2.4"
  key_links:
    - from: "bot/downloaders/ytdlp_downloader.py"
      to: "bot/downloaders/base.py"
      via: "class inheritance"
      pattern: "class YtDlpDownloader(BaseDownloader)"
---

<objective>
Implement the yt-dlp based downloader for platform-specific URLs (YouTube, Instagram, TikTok, Twitter/X, Facebook). This downloader uses yt-dlp's Python API for metadata extraction and downloading with proper async handling.

Purpose: Provide a robust downloader for popular video platforms using the industry-standard yt-dlp library. Satisfies DL-03 (metadata extraction), DL-04 (video/audio download), QF-01 through QF-05 (quality and format handling), and EH-01 (graceful error handling).
Output: YtDlpDownloader class that can extract metadata and download videos from 1000+ supported sites.
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-downloader-core/09-RESEARCH.md
@bot/downloaders/base.py
@bot/downloaders/exceptions.py
@bot/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add yt-dlp dependency</name>
  <files>requirements.txt</files>
  <action>
Add yt-dlp to the project dependencies.

Update requirements.txt to include:
```
yt-dlp>=2026.2.4
```

If requirements.txt doesn't exist, create it with:
```
# Core dependencies
python-telegram-bot>=20.0
yt-dlp>=2026.2.4
aiohttp>=3.9.0
aiofiles>=23.0.0

# Existing dependencies (preserve)
ffmpeg-python>=0.2.0
python-dotenv>=1.0.0
```

Ensure yt-dlp version constraint is >=2026.2.4 (as per research) to get the latest extractors and bug fixes.
  </action>
  <verify>
    - requirements.txt contains yt-dlp>=2026.2.4
    - pip can parse requirements.txt without errors
    - yt-dlp can be imported: python -c "import yt_dlp; print(yt_dlp.version.__version__)"
  </verify>
  <done>
    - yt-dlp added to requirements.txt with correct version
    - Dependency is installable
    - Import test passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement YtDlpDownloader class</name>
  <files>bot/downloaders/ytdlp_downloader.py</files>
  <action>
Create the YtDlpDownloader class that implements the BaseDownloader interface using yt-dlp.

Implement:

1. **Class definition**:
   ```python
   class YtDlpDownloader(BaseDownloader):
       """Downloader using yt-dlp for platform video downloads."""
   ```

2. **Properties**:
   - `name = "yt-dlp Downloader"`
   - `supported_platforms = ["YouTube", "Instagram", "TikTok", "Twitter/X", "Facebook", "1000+ sites"]`

3. **can_handle(url: str) -> bool**:
   - Use yt_dlp.YoutubeDL.extract_info with download=False and process=False
   - Return True if info extraction succeeds (URL is supported by yt-dlp)
   - Return False for ExtractorError or unsupported URLs
   - Run in thread pool: `await asyncio.to_thread(_check)`

4. **extract_metadata(url: str, options: DownloadOptions) -> dict**:
   - Use yt_dlp.YoutubeDL.extract_info(url, download=False, process=True)
   - Extract fields per DL-03:
     - title: Video title
     - duration: Duration in seconds
     - uploader: Channel/creator name
     - thumbnail: Thumbnail URL
     - filesize: File size in bytes (or filesize_approx)
     - formats: List of available formats
     - description: Video description (truncated)
   - Return structured dict with all metadata
   - Handle errors and raise MetadataExtractionError
   - Run in thread pool per research (Pattern 3)

5. **download(url: str, options: DownloadOptions) -> DownloadResult**:
   - Generate correlation_id for request tracing (per DM-02)
   - Build yt-dlp options dict:
     ```python
     ydl_opts = {
         'format': options.video_format,  # 'best[filesize<50M]/best'
         'outtmpl': output_path_template,
         'quiet': True,
         'no_warnings': True,
         'progress_hooks': [progress_hook] if options.progress_callback else [],
     }
     ```
   - Add postprocessors for audio extraction if options.extract_audio:
     ```python
     ydl_opts['postprocessors'] = [{
         'key': 'FFmpegExtractAudio',
         'preferredcodec': options.audio_codec,  # 'mp3'
         'preferredquality': options.audio_bitrate,  # '320'
     }]
     ```
   - Implement progress hook (per research Pattern 2):
     ```python
     def _progress_hook(d):
         if d['status'] == 'downloading' and options.progress_callback:
             progress = {
                 'percent': d.get('downloaded_bytes', 0) / d.get('total_bytes', 1) * 100,
                 'downloaded_bytes': d.get('downloaded_bytes', 0),
                 'total_bytes': d.get('total_bytes'),
                 'speed': d.get('speed'),
                 'eta': d.get('eta'),
             }
             # Schedule callback in event loop
             asyncio.run_coroutine_threadsafe(
                 options.progress_callback(progress),
                 self._loop
             )
     ```
   - Run download in thread pool (per research Pitfall 2):
     ```python
     return await asyncio.to_thread(self._download_sync, url, ydl_opts)
     ```
   - Return DownloadResult with success status, file path, and metadata

6. **Helper methods**:
   - `_download_sync(url, ydl_opts)` - Synchronous download wrapper
   - `_build_output_template(options)` - Build yt-dlp output path template
   - `_extract_info_sync(url, ydl_opts)` - Synchronous info extraction

7. **Error handling** (per research Error Handling example):
   - Catch ExtractorError for unsupported/unavailable content (EH-01)
   - Catch DownloadError for network failures (EH-03)
   - Convert exceptions to appropriate custom exceptions
   - Include correlation_id in all errors

Per research Pattern 2, store the event loop reference:
```python
def __init__(self):
    self._loop = asyncio.get_event_loop()
```
  </action>
  <verify>
    - YtDlpDownloader can be instantiated
    - can_handle returns True for YouTube URLs
    - can_handle returns False for invalid URLs
    - extract_metadata returns title, duration, uploader, etc.
    - download returns DownloadResult with file path
    - Progress callback is invoked during download
  </verify>
  <done>
    - YtDlpDownloader implements BaseDownloader interface
    - can_handle uses yt-dlp to check URL support
    - extract_metadata extracts all required fields (DL-03)
    - download uses thread pool for async operation
    - Progress hooks update via asyncio.run_coroutine_threadsafe
    - Format selection respects Telegram limits (QF-05)
    - Audio extraction postprocessor configured (QF-03)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add file size validation before download</name>
  <files>bot/downloaders/ytdlp_downloader.py</files>
  <action>
Implement pre-download file size validation to respect Telegram limits (per QF-05 and research Pitfall 1).

In the download method, BEFORE starting the download:

1. **Extract metadata first** (already done in extract_metadata)

2. **Check file size** from metadata:
   ```python
   filesize = info.get('filesize') or info.get('filesize_approx', 0)
   if filesize > options.max_filesize:
       raise FileTooLargeError(
           url=url,
           file_size=filesize,
           max_size=options.max_filesize,
           correlation_id=correlation_id
       )
   ```

3. **Format selection strategy** (per research):
   - Default format: `'best[filesize<50M]/best[filesize<50M]/best'`
   - This tells yt-dlp to prefer formats under 50MB
   - If no format under limit, it falls back to best available
   - Check again after format selection

4. **Size formatting for user messages**:
   ```python
   def _format_size(bytes: int) -> str:
       if bytes < 1024 * 1024:
           return f"{bytes / 1024:.1f} KB"
       elif bytes < 1024 * 1024 * 1024:
           return f"{bytes / (1024 * 1024):.1f} MB"
       else:
           return f"{bytes / (1024 * 1024 * 1024):.1f} GB"
   ```

5. **Update FileTooLargeError message**:
   - Include actual size and limit in user message
   - Suggest trying audio-only if video is too large

This prevents wasting bandwidth on downloads that will fail at Telegram upload stage.
  </action>
  <verify>
    - File size check happens before download starts
    - FileTooLargeError raised when size exceeds limit
    - Error message includes formatted sizes
    - Format selection prefers files under 50MB
  </verify>
  <done>
    - Pre-download size validation implemented
    - Format string includes filesize filter
    - User-friendly error messages with formatted sizes
    - Suggests audio-only alternative for large videos
  </done>
</task>

<task type="auto">
  <name>Task 4: Update package exports</name>
  <files>bot/downloaders/__init__.py</files>
  <action>
Update the downloaders package to export the YtDlpDownloader class.

Add to __init__.py:
```python
from .ytdlp_downloader import YtDlpDownloader

__all__ = [
    # ... existing exports ...
    'YtDlpDownloader',
]
```

Ensure YtDlpDownloader can be imported directly from the package:
```python
from bot.downloaders import YtDlpDownloader
```
  </action>
  <verify>
    - YtDlpDownloader is importable from bot.downloaders
    - No circular import errors
    - All exports listed in __all__
  </verify>
  <done>
    - YtDlpDownloader exported from package
    - Import test: from bot.downloaders import YtDlpDownloader
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Import test**: `python -c "from bot.downloaders import YtDlpDownloader; print('OK')"`
2. **Instantiation test**: Create YtDlpDownloader instance
3. **can_handle test**: Test with YouTube URL (should return True)
4. **Metadata test**: Extract metadata from a public YouTube video
5. **Size check test**: Verify file size validation works
6. **Integration test**: Full download flow (optional, network-dependent)

Note: Actual download tests require network access and should be done manually.
</verification>

<success_criteria>
- YtDlpDownloader implements BaseDownloader interface correctly
- yt-dlp dependency added to requirements.txt
- can_handle correctly identifies supported URLs using yt-dlp
- extract_metadata returns title, duration, uploader, thumbnail, filesize
- download runs in thread pool (non-blocking)
- Progress hooks provide real-time feedback
- File size validation prevents oversized downloads
- Format selection respects Telegram 50MB limit
- Audio extraction postprocessor configured
- All errors converted to appropriate custom exceptions
</success_criteria>

<output>
After completion, create `.planning/phases/09-downloader-core/09-03-SUMMARY.md`
</output>
