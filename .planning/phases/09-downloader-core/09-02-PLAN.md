---
phase: 09-downloader-core
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - bot/downloaders/base.py
  - bot/downloaders/__init__.py
  - bot/downloaders/exceptions.py
autonomous: true

must_haves:
  truths:
    - "Base downloader interface defines common contract for all downloaders"
    - "Download results include file path, metadata, and success status"
    - "Download errors provide clear, actionable error messages"
    - "All downloaders support async operations with proper cancellation"
  artifacts:
    - path: "bot/downloaders/base.py"
      provides: "Abstract base class for all downloaders"
      exports: ["BaseDownloader", "DownloadOptions"]
      min_lines: 100
    - path: "bot/downloaders/exceptions.py"
      provides: "Downloader-specific exceptions"
      exports: ["DownloadError", "URLValidationError", "MetadataExtractionError", "FileTooLargeError", "UnsupportedURLError"]
      min_lines: 80
    - path: "bot/downloaders/__init__.py"
      provides: "Updated package exports"
      exports: ["BaseDownloader", "DownloadOptions", "DownloadError", "DownloadResult"]
  key_links:
    - from: "bot/downloaders/base.py"
      to: "bot/downloaders/exceptions.py"
      via: "exception imports"
      pattern: "from .exceptions import"
---

<objective>
Create the base downloader architecture with abstract interface, common types, and comprehensive exception hierarchy. This provides the foundation that all specific downloader implementations (yt-dlp, generic HTTP) will build upon.

Purpose: Establish a consistent contract for all downloaders, ensuring they can be used interchangeably by higher-level code. Satisfies DL-04 requirement for unified download infrastructure.
Output: Base downloader interface, download options dataclass, and exception hierarchy.
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-downloader-core/09-RESEARCH.md
@bot/downloaders/__init__.py
@bot/error_handler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create downloader exception hierarchy</name>
  <files>bot/downloaders/exceptions.py</files>
  <action>
Create a comprehensive exception hierarchy for downloader operations. These exceptions should provide clear, actionable error messages for users.

Implement the following exception classes:

1. **DownloadError** (base exception)
   - Base class for all download-related errors
   - Attributes: message, url (optional), correlation_id (optional)
   - Method: to_user_message() -> str (returns user-friendly message)

2. **URLValidationError** (inherits DownloadError)
   - Raised when URL is malformed or invalid
   - Per EH-02: Clear error messages for unsupported URLs
   - to_user_message(): "The URL appears to be invalid. Please check and try again."

3. **MetadataExtractionError** (inherits DownloadError)
   - Raised when metadata cannot be extracted (per DL-03)
   - Indicates URL might be valid but content is inaccessible
   - to_user_message(): "Could not fetch video information. The content may be private or unavailable."

4. **FileTooLargeError** (inherits DownloadError)
   - Raised when file exceeds Telegram limits (per QF-05)
   - Attributes: file_size, max_size
   - to_user_message(): "The file is too large (X MB). Telegram limits file size to Y MB."

5. **UnsupportedURLError** (inherits DownloadError)
   - Raised when URL is valid but not a supported platform (per EH-02)
   - to_user_message(): "This URL is not from a supported platform. Supported: YouTube, Instagram, TikTok, Twitter/X, Facebook, and direct video links."

6. **DownloadFailedError** (inherits DownloadError)
   - Raised when download fails after retries (per EH-01)
   - Attributes: attempts_made, last_error
   - to_user_message(): "Download failed after X attempts. Please try again later."

7. **NetworkError** (inherits DownloadError)
   - Raised for transient network failures (per EH-03)
   - Indicates retry might succeed
   - to_user_message(): "Network error occurred. Retrying..."

All exceptions should:
- Support correlation_id for request tracing (per DM-02)
- Include the original URL when available
- Provide both technical details (for logs) and user-friendly messages
- Follow patterns from existing bot/error_handler.py
  </action>
  <verify>
    - All exception classes can be imported
    - Each exception has to_user_message() method
    - Exception hierarchy is correct (isinstance checks work)
    - Correlation ID is preserved through exception chain
  </verify>
  <done>
    - DownloadError base class with correlation_id support
    - 6 specific exception classes defined
    - User-friendly error messages for all exceptions
    - Exception classes follow existing error patterns
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DownloadOptions dataclass</name>
  <files>bot/downloaders/base.py</files>
  <action>
Create a DownloadOptions dataclass that encapsulates all download configuration parameters. This provides a type-safe way to pass options to downloaders.

Implement DownloadOptions with fields:

1. **Output settings**:
   - output_path: Optional[str] = None (directory to save file)
   - filename: Optional[str] = None (custom filename, else auto-generated)

2. **Quality settings** (per QF-01, QF-02, QF-03):
   - video_format: str = "best[filesize<50M]/best" (yt-dlp format string)
   - audio_format: str = "bestaudio[filesize<50M]/bestaudio"
   - preferred_quality: str = "best" (or specific like "720p")
   - max_filesize: int = 50 * 1024 * 1024 (50MB default, per QF-05)

3. **Format preferences**:
   - output_format: str = "mp4" (preferred container, per QF-02)
   - audio_codec: str = "mp3" (per QF-03)
   - audio_bitrate: str = "320k" (per QF-03)

4. **Download mode**:
   - extract_audio: bool = False (download audio only, per DL-04)
   - keep_video: bool = True (keep video when extracting audio)

5. **Retry settings** (per EH-03):
   - max_retries: int = 3
   - retry_delay: int = 2

6. **Timeout settings**:
   - metadata_timeout: int = 30
   - download_timeout: int = 300

7. **Progress callback**:
   - progress_callback: Optional[Callable[[dict], None]] = None

The dataclass should:
- Use @dataclass(frozen=True) for immutability
- Provide a from_config() classmethod that creates options from bot.config
- Include validation in __post_init__ (e.g., max_filesize <= 50MB)
- Have sensible defaults that align with config.py values
  </action>
  <verify>
    - DownloadOptions can be instantiated with defaults
    - from_config() creates valid options from bot.config
    - Validation rejects invalid values (max_filesize > 50MB)
    - Frozen dataclass prevents accidental mutation
  </verify>
  <done>
    - DownloadOptions dataclass with all fields
    - from_config() classmethod implemented
    - Validation ensures Telegram limits respected
    - Sensible defaults match config.py
  </done>
</task>

<task type="auto">
  <name>Task 3: Create BaseDownloader abstract class</name>
  <files>bot/downloaders/base.py</files>
  <action>
Create the BaseDownloader abstract base class that defines the contract all downloader implementations must follow.

Implement BaseDownloader with:

1. **Abstract methods** (must be implemented by subclasses):
   - `can_handle(url: str) -> bool` - Check if this downloader can handle the URL
   - `extract_metadata(url: str, options: DownloadOptions) -> dict` - Extract metadata without downloading (per DL-03)
   - `download(url: str, options: DownloadOptions) -> DownloadResult` - Perform the actual download

2. **Concrete methods** (shared implementation):
   - `validate_url(url: str) -> bool` - Basic URL validation (scheme, netloc)
   - `check_filesize(size: int, max_size: int) -> None` - Raise FileTooLargeError if needed
   - `format_duration(seconds: int) -> str` - Format duration as "MM:SS" or "HH:MM:SS"
   - `format_filesize(bytes: int) -> str` - Format size as "X MB" or "X GB"

3. **Properties**:
   - `name: str` - Human-readable downloader name (abstract)
   - `supported_platforms: list[str]` - List of platform names supported

4. **Utility methods**:
   - `_generate_correlation_id() -> str` - Generate unique ID for request tracing (per DM-02)
   - `_sanitize_filename(title: str) -> str` - Clean filename for filesystem
   - `_is_valid_url(url: str) -> bool` - Validate URL format

The class should:
- Use ABC (Abstract Base Class) with @abstractmethod decorators
- Include proper type hints for all methods
- Follow async pattern: all main methods are async
- Include docstrings with Args, Returns, Raises sections
- Import and use the exception classes from exceptions.py

Example usage pattern:
```python
class MyDownloader(BaseDownloader):
    @property
    def name(self) -> str:
        return "My Downloader"

    async def can_handle(self, url: str) -> bool:
        return url.startswith("https://example.com")

    async def extract_metadata(self, url, options):
        # Implementation
        pass

    async def download(self, url, options):
        # Implementation
        pass
```
  </action>
  <verify>
    - BaseDownloader cannot be instantiated directly (abstract)
    - Subclass implementing all abstract methods can be instantiated
    - Utility methods work correctly (validate_url, format_duration, etc.)
    - Type hints are correct and mypy-compatible
  </verify>
  <done>
    - BaseDownloader ABC with 3 abstract methods
    - Utility methods for URL validation, filesize checking, formatting
    - Correlation ID generation for request tracing
    - Proper docstrings and type hints
    - Cannot instantiate abstract class directly
  </done>
</task>

<task type="auto">
  <name>Task 4: Update package exports</name>
  <files>bot/downloaders/__init__.py</files>
  <action>
Update the bot/downloaders/__init__.py to export all new classes and exceptions.

Update exports to include:
- From base.py: BaseDownloader, DownloadOptions
- From exceptions.py: all exception classes
- Keep existing: DownloadResult (update if needed)

Ensure the module has proper:
- __all__ list for explicit exports
- Module-level docstring
- Logging setup

The __init__.py should now provide a clean public API:
```python
from bot.downloaders import (
    BaseDownloader,
    DownloadOptions,
    DownloadResult,
    DownloadError,
    URLValidationError,
    # ... etc
)
```
  </action>
  <verify>
    - All new classes are importable from bot.downloaders
    - __all__ list is complete and accurate
    - No import errors when importing the package
  </verify>
  <done>
    - __init__.py exports all public classes
    - __all__ list defined
    - Clean import: from bot.downloaders import BaseDownloader, DownloadOptions
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Abstract class test**: Verify BaseDownloader cannot be instantiated
2. **Subclass test**: Create test subclass, verify it can be instantiated
3. **Exception test**: Raise each exception type, verify user messages
4. **Options test**: Create DownloadOptions, verify validation
5. **Import test**: Verify all exports work from bot.downloaders

Run: `python -c "from bot.downloaders import BaseDownloader, DownloadOptions; print('OK')"`
</verification>

<success_criteria>
- BaseDownloader abstract class defines clear contract for all downloaders
- DownloadOptions dataclass encapsulates all download configuration
- Exception hierarchy provides specific, actionable error types
- All classes are properly exported from bot.downloaders package
- Code follows Python ABC patterns and type hint best practices
- No breaking changes to existing code
</success_criteria>

<output>
After completion, create `.planning/phases/09-downloader-core/09-02-SUMMARY.md`
</output>
