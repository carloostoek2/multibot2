---
phase: 09-downloader-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/downloaders/__init__.py
  - bot/downloaders/url_detector.py
  - bot/config.py
autonomous: true

must_haves:
  truths:
    - "Bot automatically detects URLs in any message without requiring /download command"
    - "URLs are extracted from both plain text and text_link entities"
    - "URLs are classified as platform URLs or generic video URLs"
    - "Invalid or malformed URLs are rejected with clear error messages"
  artifacts:
    - path: "bot/downloaders/__init__.py"
      provides: "Downloader package exports"
      min_lines: 20
    - path: "bot/downloaders/url_detector.py"
      provides: "URL detection, extraction, and classification"
      exports: ["URLDetector", "URLType", "detect_urls", "classify_url"]
      min_lines: 150
    - path: "bot/config.py"
      provides: "Download configuration settings"
      contains: "DOWNLOAD_MAX_SIZE_MB, DOWNLOAD_TIMEOUT"
  key_links:
    - from: "bot/downloaders/url_detector.py"
      to: "bot/config.py"
      via: "config import"
      pattern: "from bot.config import config"
---

<objective>
Implement URL auto-detection and validation infrastructure. Create the foundation for automatic URL detection in messages, extraction from various message entities, and classification of URLs by type (platform vs generic).

Purpose: Enable the bot to automatically detect URLs in any user message without requiring explicit commands, satisfying DL-01, DL-02, and DL-06 requirements.
Output: URL detection module with entity extraction and URL classification capabilities.
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-downloader-core/09-RESEARCH.md
@bot/config.py
@bot/handlers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create downloaders package structure</name>
  <files>bot/downloaders/__init__.py</files>
  <action>
Create the bot/downloaders/ directory and __init__.py file. This package will contain all downloader-related modules.

The __init__.py should:
1. Define the public API exports for the downloaders package
2. Import and re-export key classes/functions that will be created in subsequent plans
3. Set up proper logging for the downloaders module
4. Define common types and exceptions used across downloaders

Create placeholder imports for:
- URLDetector (from url_detector)
- DownloadError (custom exception)
- DownloadResult (dataclass for download results)

For now, create stub classes that will be fully implemented in later plans:
```python
class DownloadError(Exception):
    """Base exception for download operations."""
    pass

@dataclass
class DownloadResult:
    """Result of a download operation."""
    success: bool
    file_path: Optional[str] = None
    error_message: Optional[str] = None
    metadata: Optional[dict] = None
```
  </action>
  <verify>
    - Python can import bot.downloaders without errors
    - Directory bot/downloaders/ exists with __init__.py
    - Placeholder classes are defined and exportable
  </verify>
  <done>
    - bot/downloaders/__init__.py created with package exports
    - DownloadError and DownloadResult stubs defined
    - Module imports successfully: python -c "from bot.downloaders import DownloadError"
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement URL detection and extraction</name>
  <files>bot/downloaders/url_detector.py</files>
  <action>
Create the URL detector module that handles automatic URL detection in Telegram messages.

Implement:

1. **URLType Enum** - Classify URLs by type:
   - PLATFORM (YouTube, Instagram, TikTok, Twitter/X, Facebook)
   - GENERIC_VIDEO (direct .mp4, .webm, .mov URLs)
   - UNKNOWN (not a video URL)

2. **URLDetector class** with methods:
   - `extract_urls(message_text: str, entities: list) -> list[str]` - Extract URLs from message text and entities
   - `classify_url(url: str) -> URLType` - Determine if URL is platform-specific or generic video
   - `is_supported(url: str) -> bool` - Check if URL can be handled by any downloader

3. **URL extraction logic** (per 09-RESEARCH.md Pattern 5):
   - Check message.entities for 'url' type entities
   - Check for 'text_link' entities (hidden URLs behind clickable text)
   - Fallback to regex pattern matching for any missed URLs
   - Use regex pattern: r'https?://\S+'

4. **Platform detection patterns**:
   - YouTube: youtube.com, youtu.be, youtube.com/shorts
   - Instagram: instagram.com/p/, instagram.com/reel/, instagram.com/stories/
   - TikTok: tiktok.com/@, vm.tiktok.com
   - Twitter/X: twitter.com, x.com
   - Facebook: facebook.com/watch, fb.watch
   - Generic video: .mp4, .webm, .mov extensions

5. **URL validation**:
   - Check URL format is valid (has scheme, netloc)
   - Reject obviously invalid URLs
   - Return clear error context for validation failures

Per research, do NOT use complex regex for platform validation - use simple domain matching. yt-dlp will handle actual URL validation during extraction.
  </action>
  <verify>
    - Unit test: extract_urls extracts plain text URLs
    - Unit test: extract_urls handles text_link entities
    - Unit test: classify_url correctly identifies YouTube URLs
    - Unit test: classify_url correctly identifies generic video URLs
    - Unit test: is_supported returns False for non-video URLs
  </verify>
  <done>
    - URLType enum with PLATFORM, GENERIC_VIDEO, UNKNOWN values
    - URLDetector class with extract_urls, classify_url, is_supported methods
    - URL extraction handles both entities and regex fallback
    - Platform detection covers all 5 platforms + generic video
    - All unit tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Add download configuration settings</name>
  <files>bot/config.py</files>
  <action>
Extend the BotConfig class with download-specific configuration settings.

Add new configuration fields:

1. **File size limits** (per QF-05, Telegram constraints):
   - DOWNLOAD_MAX_SIZE_MB: int = 50 (Telegram bot upload limit)
   - DOWNLOAD_MAX_SIZE_GENERIC_MB: int = 50 (for generic HTTP downloads)

2. **Timeout settings**:
   - DOWNLOAD_TIMEOUT: int = 300 (5 minutes for downloads)
   - DOWNLOAD_METADATA_TIMEOUT: int = 30 (30 seconds for metadata extraction)

3. **Quality settings** (per QF-01, QF-02, QF-03):
   - DOWNLOAD_VIDEO_FORMAT: str = "best[filesize<50M]/best" (yt-dlp format string)
   - DOWNLOAD_AUDIO_FORMAT: str = "bestaudio[filesize<50M]/bestaudio"
   - DOWNLOAD_AUDIO_QUALITY: str = "320" (MP3 bitrate)
   - DOWNLOAD_VIDEO_PREFERENCE: str = "mp4" (preferred container)

4. **Concurrent download settings** (per DM-01):
   - DOWNLOAD_MAX_CONCURRENT: int = 5 (semaphore limit)

5. **Retry settings** (per EH-03):
   - DOWNLOAD_MAX_RETRIES: int = 3
   - DOWNLOAD_RETRY_DELAY: int = 2 (seconds between retries)

Update load_config() to read these from environment variables with sensible defaults.

Add validation in __post_init__:
- DOWNLOAD_MAX_SIZE_MB must be <= 50 (Telegram limit)
- Timeout values must be positive
- DOWNLOAD_MAX_CONCURRENT must be >= 1
  </action>
  <verify>
    - config.DOWNLOAD_MAX_SIZE_MB returns 50 by default
    - config.DOWNLOAD_TIMEOUT returns 300 by default
    - Environment variable override works: DOWNLOAD_MAX_SIZE_MB=40
    - Validation rejects invalid values: DOWNLOAD_MAX_SIZE_MB=100 raises error
    - All existing config tests still pass
  </verify>
  <done>
    - BotConfig has all download-related fields
    - load_config() reads download settings from env vars
    - Validation ensures Telegram limits are respected
    - Backward compatible with existing config usage
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Import test**: `python -c "from bot.downloaders import URLDetector; print('OK')"`
2. **Extraction test**: Verify extract_urls handles both entity types
3. **Classification test**: Verify classify_url identifies platforms correctly
4. **Config test**: Verify new download settings are accessible
5. **Integration check**: Ensure no circular imports with existing bot modules

Run: `python -m pytest tests/unit/test_url_detector.py -v` (if tests exist)
</verification>

<success_criteria>
- bot/downloaders/ package exists and is importable
- URLDetector can extract URLs from message text and entities
- URL classification correctly identifies platform vs generic URLs
- Configuration includes all download-related settings
- Code follows existing patterns in bot/config.py
- No breaking changes to existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/09-downloader-core/09-01-SUMMARY.md`
</output>
