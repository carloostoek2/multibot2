---
phase: 02-error-handling-configuration
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - bot/temp_manager.py
  - bot/main.py
autonomous: true

must_haves:
  truths:
    - "Old temporary directories from previous bot runs are cleaned up on startup"
    - "Bot handles shutdown signals gracefully with proper cleanup"
    - "No orphaned temp directories remain after bot stops"
    - "Disk space is monitored and protected from temp file accumulation"
  artifacts:
    - path: "bot/temp_manager.py"
      provides: "Startup cleanup and graceful shutdown support"
      exports: ["TempManager", "cleanup_old_temp_directories", "active_temp_managers"]
    - path: "bot/main.py"
      provides: "Signal handlers for graceful shutdown"
  key_links:
    - from: "bot/main.py"
      to: "bot/temp_manager.py"
      via: "import cleanup_old_temp_directories, active_temp_managers"
---

<objective>
Implement startup cleanup of orphaned temp directories and graceful shutdown handling.

Purpose: Prevent disk space exhaustion from crashes, ensure clean resource cleanup on shutdown, provide safety net for resource management.
Output: cleanup_old_temp_directories function, signal handlers for graceful shutdown, active temp manager tracking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bot/temp_manager.py
@bot/main.py
@.planning/phases/02-error-handling-configuration/02-RESEARCH.md

## Current State
TempManager has context manager cleanup but lacks:
- Startup cleanup of old directories
- Signal handling for graceful shutdown
- Tracking of active temp managers

## Research Findings
Startup cleanup requirements:
- Scan for videonote_* directories in temp
- Remove directories older than 24 hours
- Log cleanup actions

Signal handling:
- Handle SIGINT (Ctrl+C) and SIGTERM
- Cleanup active temp managers
- Exit cleanly
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add startup cleanup to temp_manager.py</name>
  <files>bot/temp_manager.py</files>
  <action>
Add startup cleanup functionality to temp_manager.py:

1. Add imports at top of file:
   - glob
   - time
   - atexit (for cleanup registration)

2. Create global set to track active temp managers:
   ```python
   active_temp_managers: Set['TempManager'] = set()
   ```

3. Create cleanup_old_temp_directories(max_age_hours: int = 24) function:
   ```python
   def cleanup_old_temp_directories(max_age_hours: int = 24) -> int:
       """Remove old temporary directories on startup.

       Args:
           max_age_hours: Remove directories older than this many hours

       Returns:
           Number of directories removed
       """
       temp_dir = tempfile.gettempdir()
       pattern = os.path.join(temp_dir, "videonote_*")

       current_time = time.time()
       max_age_seconds = max_age_hours * 3600

       removed_count = 0
       for dir_path in glob.glob(pattern):
           try:
               dir_time = os.path.getctime(dir_path)
               age_seconds = current_time - dir_time

               if age_seconds > max_age_seconds:
                   shutil.rmtree(dir_path, ignore_errors=True)
                   removed_count += 1
                   logger.info(f"Removed old temp directory: {dir_path} (age: {age_seconds/3600:.1f} hours)")
           except Exception as e:
               logger.warning(f"Failed to check/remove old temp directory {dir_path}: {e}")

       if removed_count > 0:
           logger.info(f"Cleaned up {removed_count} old temporary directories")

       return removed_count
   ```

4. Update TempManager.__init__ to register itself:
   - Add self to active_temp_managers set
   - Log registration

5. Update TempManager.cleanup to unregister itself:
   - Remove self from active_temp_managers set
   - Keep existing cleanup logic

6. Add module-level call at bottom of file:
   ```python
   # Clean up old temp directories on module import (startup)
   try:
       cleanup_old_temp_directories()
   except Exception as e:
       logger.warning(f"Failed to cleanup old temp directories on startup: {e}")
   ```

This ensures old directories are cleaned up when the module is imported.
  </action>
  <verify>python -c "from bot.temp_manager import cleanup_old_temp_directories, active_temp_managers; print('Cleanup function available')"</verify>
  <done>cleanup_old_temp_directories function exists, active_temp_managers tracking implemented, module calls cleanup on import</done>
</task>

<task type="auto">
  <name>Task 2: Add signal handlers for graceful shutdown</name>
  <files>bot/main.py</files>
  <action>
Add signal handling for graceful shutdown to main.py:

1. Add imports at top:
   - signal
   - sys
   - from bot.temp_manager import active_temp_managers

2. Create signal_handler function before main():
   ```python
   def signal_handler(signum, frame):
       """Handle shutdown signals gracefully."""
       signal_name = signal.Signals(signum).name
       logger.info(f"Received signal {signal_name} ({signum}), shutting down gracefully...")

       # Cleanup any active temp managers
       cleanup_count = 0
       for temp_mgr in list(active_temp_managers):
           try:
               temp_mgr.cleanup()
               cleanup_count += 1
           except Exception as e:
               logger.warning(f"Error during temp manager cleanup: {e}")

       if cleanup_count > 0:
           logger.info(f"Cleaned up {cleanup_count} active temp managers")

       logger.info("Shutdown complete")
       sys.exit(0)
   ```

3. Register signal handlers at start of main() function:
   ```python
   def main() -> None:
       """Start the bot."""
       # Register signal handlers for graceful shutdown
       signal.signal(signal.SIGINT, signal_handler)
       signal.signal(signal.SIGTERM, signal_handler)
       logger.info("Signal handlers registered for graceful shutdown")

       # Rest of existing main() code...
   ```

4. Ensure the signal handlers work on the current platform (Linux/Android supports both SIGINT and SIGTERM)

This ensures temp directories are cleaned up when the bot is stopped with Ctrl+C or kill command.
  </action>
  <verify>python -c "import signal; from bot.main import signal_handler; print('Signal handler defined')"</verify>
  <done>Signal handlers registered for SIGINT and SIGTERM, cleanup active temp managers on shutdown</done>
</task>

<task type="auto">
  <name>Task 3: Update TempManager to track active instances</name>
  <files>bot/temp_manager.py</files>
  <action>
Update TempManager class to properly track active instances:

1. Add to TempManager.__init__ after creating temp_dir:
   ```python
   def __init__(self):
       """Create a unique temporary directory."""
       self.temp_dir = tempfile.mkdtemp(prefix="videonote_")
       self._tracked_files: List[str] = []

       # Register in active managers set
       active_temp_managers.add(self)

       logger.debug(f"Created temp directory: {self.temp_dir}")
   ```

2. Update TempManager.cleanup to unregister:
   ```python
   def cleanup(self):
       """Remove the temporary directory and all its contents."""
       # Unregister from active managers
       try:
           active_temp_managers.discard(self)
       except Exception:
           pass

       # Existing cleanup logic...
       if os.path.exists(self.temp_dir):
           try:
               shutil.rmtree(self.temp_dir, ignore_errors=True)
               logger.debug(f"Cleaned up temp directory: {self.temp_dir}")
           except Exception as e:
               logger.warning(f"Could not fully clean up temp directory {self.temp_dir}: {e}")
       self._tracked_files.clear()
   ```

3. Update TempManager.__exit__ to ensure cleanup is called:
   ```python
   def __exit__(self, exc_type, exc_val, exc_tb):
       """Exit context manager - always cleanup."""
       self.cleanup()
       return False  # Don't suppress exceptions
   ```

4. Ensure the active_temp_managers set is defined at module level before the class

This ensures TempManager instances are tracked and can be cleaned up on shutdown.
  </action>
  <verify>python -c "from bot.temp_manager import TempManager, active_temp_managers; tm = TempManager(); print('In active set:', tm in active_temp_managers); tm.cleanup(); print('After cleanup:', tm in active_temp_managers)"</verify>
  <done>TempManager registers itself on creation and unregisters on cleanup, active_temp_managers tracks instances</done>
</task>

</tasks>

<verification>
1. Cleanup function works: python -c "from bot.temp_manager import cleanup_old_temp_directories; print(cleanup_old_temp_directories())"
2. Active managers tracking: python -c "from bot.temp_manager import TempManager, active_temp_managers; tm = TempManager(); print(len(active_temp_managers)); tm.cleanup()"
3. Signal handlers defined: python -c "from bot.main import signal_handler"
4. Module imports cleanly: python -c "from bot import temp_manager"
</verification>

<success_criteria>
- cleanup_old_temp_directories function removes directories older than 24 hours
- Function is called on module import (startup)
- TempManager instances register in active_temp_managers on creation
- TempManager instances unregister on cleanup
- Signal handlers registered for SIGINT and SIGTERM in main.py
- Signal handlers cleanup active temp managers before exit
- No memory leaks from temp manager tracking (weak references or proper cleanup)
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-handling-configuration/02-04-SUMMARY.md`
</output>
