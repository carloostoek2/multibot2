---
phase: 02-error-handling-configuration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/error_handler.py
  - bot/handlers.py
autonomous: true

must_haves:
  truths:
    - "Telegram API errors (network, timeout, bad request) are caught and handled gracefully"
    - "Users receive Spanish error messages for Telegram API failures"
    - "Transient errors have retry logic where appropriate"
    - "All errors are logged with full context for debugging"
  artifacts:
    - path: "bot/error_handler.py"
      provides: "Enhanced error handling with Telegram API error support"
      exports: ["error_handler", "handle_processing_error", "ERROR_MESSAGES"]
  key_links:
    - from: "bot/handlers.py"
      to: "bot/error_handler.py"
      via: "import and call error handlers"
      pattern: "handle_processing_error\("
---

<objective>
Enhance error handling to gracefully handle Telegram API errors and network issues.

Purpose: Prevent bot crashes from external failures, provide clear feedback to users when Telegram/network issues occur, implement resilience through retry logic.
Output: Enhanced error_handler.py with Telegram API error support, retry logic in handlers for transient failures.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bot/error_handler.py
@bot/handlers.py
@.planning/phases/02-error-handling-configuration/02-RESEARCH.md

## Current State
error_handler.py has custom exceptions for video processing but lacks:
- Telegram API error handling (NetworkError, TimedOut, BadRequest)
- Retry logic for transient failures
- Specific handling for download timeouts vs processing timeouts

## Research Findings
Telegram errors to handle:
- NetworkError: Connection issues
- TimedOut: Operation timeout
- BadRequest: Invalid request
- RetryAfter: Rate limiting (less common for bots)

Retry logic should be applied to:
- Video downloads (transient network issues)
- File operations

Error messages should remain in Spanish for users.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Telegram API error handling</name>
  <files>bot/error_handler.py</files>
  <action>
Enhance error_handler.py with Telegram API error support:

1. Add imports from telegram.error:
   - NetworkError
   - TimedOut
   - BadRequest
   - RetryAfter
   - TelegramError (base class)

2. Add Telegram errors to ERROR_MESSAGES dict with Spanish messages:
   - NetworkError: "Error de conexión. Por favor intenta de nuevo."
   - TimedOut: "La operación tardó demasiado. Intenta con un archivo más pequeño."
   - BadRequest: "Solicitud inválida. Verifica el archivo e intenta de nuevo."
   - RetryAfter: "Demasiadas solicitudes. Por favor espera un momento."
   - TelegramError: "Error de Telegram. Por favor intenta de nuevo."

3. Update error_handler() function:
   - Keep existing logic for checking error types
   - Add specific handling for Telegram errors with appropriate log levels:
     * NetworkError/TimedOut: log as warning (transient)
     * BadRequest: log as info (user error)
     * Others: log as error

4. Ensure the error type checking works with both custom exceptions and Telegram errors

5. Update handle_processing_error() to also check for Telegram errors

The error handler should check for Telegram errors in addition to custom exceptions.
  </action>
  <verify>python -c "from bot.error_handler import error_handler; from telegram.error import NetworkError; print('Telegram error imports work')"</verify>
  <done>Telegram error imports added, ERROR_MESSAGES updated with Telegram errors, error_handler checks for Telegram errors</done>
</task>

<task type="auto">
  <name>Task 2: Add retry logic for video downloads</name>
  <files>bot/handlers.py</files>
  <action>
Implement retry logic for video downloads in handlers.py:

1. Create helper function _download_with_retry():
   ```python
   async def _download_with_retry(file, destination_path: str, max_retries: int = 3) -> bool:
       """Download file with retry logic for transient failures."""
       for attempt in range(max_retries):
           try:
               await file.download_to_drive(destination_path)
               return True
           except (NetworkError, TimedOut) as e:
               if attempt < max_retries - 1:
                   logger.warning(f"Download attempt {attempt + 1} failed, retrying...")
                   await asyncio.sleep(1 * (attempt + 1))  # Exponential backoff
               else:
                   raise
       return False
   ```

2. Replace direct file.download_to_drive() calls with _download_with_retry() in:
   - handle_video() - _process_video_with_timeout()
   - handle_convert_command()
   - handle_extract_audio_command()
   - handle_split_command()
   - handle_join_video()

3. Import NetworkError and TimedOut from telegram.error in handlers.py

4. Ensure the retry logic logs each attempt for debugging

5. After max retries, let the exception propagate to be handled by error_handler

This provides resilience against transient network issues without changing the user experience for permanent failures.
  </action>
  <verify>grep -n "_download_with_retry\|NetworkError\|TimedOut" bot/handlers.py | head -10</verify>
  <done>Retry logic implemented, _download_with_retry function exists and is used in all download locations</done>
</task>

<task type="auto">
  <name>Task 3: Enhance logging with correlation IDs</name>
  <files>bot/handlers.py</files>
  <action>
Add correlation IDs to improve request tracking in logs:

1. Import uuid module in handlers.py

2. At the start of each handler function (handle_video, handle_convert_command, etc.), generate a correlation ID:
   ```python
   correlation_id = str(uuid.uuid4())[:8]
   logger.info(f"[{correlation_id}] Starting video processing for user {user_id}")
   ```

3. Pass the correlation ID through the processing flow:
   - Add correlation_id parameter to _process_video_with_timeout()
   - Add correlation_id parameter to _download_with_retry()
   - Log the correlation ID at key points:
     * Start of processing
     * Download complete
     * Processing complete
     * Error occurred

4. Update log messages to include correlation ID:
   - Change: logger.info(f"Video downloaded to {input_path}")
   - To: logger.info(f"[{correlation_id}] Video downloaded to {input_path}")

5. Apply to all handlers:
   - handle_video
   - handle_convert_command
   - handle_extract_audio_command
   - handle_split_command
   - handle_join_start, handle_join_video, handle_join_done

This allows tracing a single request through multiple log entries, which is crucial for debugging issues in production.
  </action>
  <verify>grep -n "correlation_id\|uuid.uuid4" bot/handlers.py | head -10</verify>
  <done>Correlation IDs are generated in each handler and included in log messages throughout the processing flow</done>
</task>

</tasks>

<verification>
1. Telegram errors import: python -c "from bot.error_handler import error_handler; from telegram.error import NetworkError, TimedOut, BadRequest"
2. Error messages updated: grep -A1 "NetworkError" bot/error_handler.py
3. Retry function exists: grep "_download_with_retry" bot/handlers.py
4. Correlation IDs present: grep "correlation_id" bot/handlers.py
</verification>

<success_criteria>
- Telegram API errors (NetworkError, TimedOut, BadRequest) are imported and handled
- Spanish error messages exist for all Telegram error types
- _download_with_retry function provides retry logic with exponential backoff
- All video download operations use retry logic
- Correlation IDs track requests through the processing flow
- Error handler distinguishes between transient and permanent errors in logging
- Bot handles network failures gracefully without crashing
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-handling-configuration/02-03-SUMMARY.md`
</output>
