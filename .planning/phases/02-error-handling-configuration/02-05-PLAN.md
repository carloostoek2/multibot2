---
phase: 02-error-handling-configuration
plan: 05
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - bot/main.py
autonomous: true

must_haves:
  truths:
    - "Log level is configurable via LOG_LEVEL environment variable"
    - "Bot logs operational events at appropriate levels"
    - "Logging configuration is centralized and consistent"
    - "Debug logging can be enabled for troubleshooting"
  artifacts:
    - path: "bot/main.py"
      provides: "Configurable logging setup"
  key_links:
    - from: "bot/main.py"
      to: "bot/config.py"
      via: "import config.LOG_LEVEL"
---

<objective>
Enhance logging to support configurable log levels via environment variables.

Purpose: Enable debugging in production, allow operators to control log verbosity, maintain consistent logging across modules.
Output: Enhanced logging setup in main.py using config.LOG_LEVEL, consistent log levels across handlers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bot/main.py
@bot/config.py
@.planning/phases/02-error-handling-configuration/02-01-PLAN.md

## Current State
main.py has basic logging setup with hardcoded INFO level:
```python
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
```

## Dependencies
This plan depends on 02-01 (Configuration Enhancement) which adds LOG_LEVEL to BotConfig.

## Requirements
- Use config.LOG_LEVEL for logging level
- Support DEBUG, INFO, WARNING, ERROR, CRITICAL levels
- Maintain consistent format
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update logging setup to use config.LOG_LEVEL</name>
  <files>bot/main.py</files>
  <action>
Update main.py to use configurable log level:

1. Move the config import BEFORE logging setup:
   ```python
   from bot.config import config
   ```

2. Update logging.basicConfig to use config.LOG_LEVEL:
   ```python
   # Configure logging based on config
   logging.basicConfig(
       format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
       level=getattr(logging, config.LOG_LEVEL.upper())
   )
   ```

3. Add validation that LOG_LEVEL is valid:
   ```python
   # Validate log level
   valid_levels = ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']
   if config.LOG_LEVEL.upper() not in valid_levels:
       print(f"Warning: Invalid LOG_LEVEL '{config.LOG_LEVEL}'. Using INFO.", file=sys.stderr)
       log_level = logging.INFO
   else:
       log_level = getattr(logging, config.LOG_LEVEL.upper())

   logging.basicConfig(
       format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
       level=log_level
   )
   ```

4. Add log message showing the configured level:
   ```python
   logger = logging.getLogger(__name__)
   logger.info(f"Logging configured at level: {config.LOG_LEVEL}")
   ```

5. Ensure imports are in correct order:
   - First: config import
   - Then: logging setup using config
   - Then: other imports

This ensures the logging level is set before any loggers are created.
  </action>
  <verify>python -c "from bot.main import logger; print('Main module loads with configurable logging')"</verify>
  <done>Logging setup uses config.LOG_LEVEL, validation ensures valid level, startup message shows configured level</done>
</task>

<task type="auto">
  <name>Task 2: Review and standardize log levels in handlers</name>
  <files>bot/handlers.py</files>
  <action>
Review and adjust log levels in handlers.py for consistency:

1. Ensure appropriate log levels are used:
   - DEBUG: Detailed information (temp directory creation, file paths)
   - INFO: Normal operations (processing started, completed, download started)
   - WARNING: Non-fatal issues (cleanup failures, message deletion failures)
   - ERROR: Errors that affect user (download failed, processing failed)
   - EXCEPTION: Unexpected errors with traceback

2. Review current log statements and adjust if needed:
   - "Video received from user" -> INFO (correct)
   - "Processing video for user" -> INFO (correct)
   - "Video processed successfully" -> INFO (correct)
   - "Could not send processing message" -> WARNING (correct)
   - "Failed to download video" -> ERROR (correct)

3. Add debug logging for troubleshooting:
   - Log file sizes: logger.debug(f"[{correlation_id}] Video file size: {video.file_size} bytes")
   - Log processing parameters: logger.debug(f"[{correlation_id}] Processing with timeout: {config.PROCESSING_TIMEOUT}s")

4. Ensure all log messages include correlation ID (from 02-03)

5. Check that no sensitive data is logged (BOT_TOKEN, full file paths with user data)

The goal is consistent, useful logging at each level.
  </action>
  <verify>grep -n "logger\." bot/handlers.py | head -20</verify>
  <done>Log levels are appropriate for each message type, debug logging added for troubleshooting, no sensitive data logged</done>
</task>

<task type="auto">
  <name>Task 3: Test logging configuration</name>
  <files>bot/main.py</files>
  <action>
Test that logging configuration works correctly:

1. Test with default INFO level:
   ```bash
   python -c "from bot.main import main; print('INFO level works')"
   ```

2. Test with DEBUG level (set environment variable):
   ```bash
   LOG_LEVEL=DEBUG python -c "
   import os
   os.environ['LOG_LEVEL'] = 'DEBUG'
   from bot.config import config
   print(f'Config LOG_LEVEL: {config.LOG_LEVEL}')
   import logging
   print(f'Logging level: {logging.getLevelName(logging.getLogger().level)}')
   "
   ```

3. Test with invalid level (should fallback to INFO):
   ```bash
   LOG_LEVEL=INVALID python -c "
   import os
   os.environ['LOG_LEVEL'] = 'INVALID'
   from bot.config import config
   import logging
   level = getattr(logging, config.LOG_LEVEL.upper(), logging.INFO)
   print(f'Fallback level: {logging.getLevelName(level)}')
   "
   ```

4. Verify the bot starts correctly with each log level

5. Document the LOG_LEVEL options in comments

This ensures the logging configuration is robust and handles edge cases.
  </action>
  <verify>LOG_LEVEL=DEBUG python -c "import os; os.environ['LOG_LEVEL']='DEBUG'; from bot.config import config; print(f'Level: {config.LOG_LEVEL}')"</verify>
  <done>Logging works with different levels, invalid levels fallback gracefully, bot starts correctly</done>
</task>

</tasks>

<verification>
1. Config import before logging: grep -n "from bot.config" bot/main.py
2. Logging uses config: grep -n "config.LOG_LEVEL" bot/main.py
3. Log levels appropriate: grep "logger\." bot/handlers.py | wc -l
4. Bot starts: python -c "from bot.main import main"
</verification>

<success_criteria>
- Logging level is read from config.LOG_LEVEL
- Valid log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Invalid log levels fallback to INFO with warning
- Startup message shows configured log level
- Handlers use appropriate log levels for each message type
- Debug logging available for troubleshooting
- No sensitive data in logs
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-handling-configuration/02-05-SUMMARY.md`
</output>
