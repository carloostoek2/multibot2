---
phase: 10-platform-handlers
plan: 05
type: execute
wave: 4
depends_on: ["10-01", "10-02", "10-03", "10-04"]
files_modified:
  - bot/downloaders/platform_router.py
  - bot/downloaders/__init__.py
  - bot/downloaders/url_detector.py
autonomous: true

must_haves:
  truths:
    - "Platform router automatically selects the correct downloader for any URL"
    - "YouTube URLs are routed to YouTubeDownloader"
    - "Instagram URLs are routed to InstagramDownloader"
    - "TikTok URLs are routed to TikTokDownloader"
    - "Twitter/X URLs are routed to TwitterDownloader"
    - "Facebook URLs are routed to FacebookDownloader"
    - "Generic video URLs fall back to GenericDownloader or YtDlpDownloader"
    - "HTML pages are handled by HTMLVideoExtractor"
  artifacts:
    - path: "bot/downloaders/platform_router.py"
      provides: "Platform router for automatic downloader selection"
      exports: ["PlatformRouter", "get_downloader_for_url", "RouteResult"]
      min_lines: 250
    - path: "bot/downloaders/__init__.py"
      provides: "Updated package exports with router"
      exports: ["PlatformRouter", "get_downloader_for_url"]
  key_links:
    - from: "bot/downloaders/platform_router.py"
      to: "bot/downloaders/platforms/__init__.py"
      via: "imports all platform handlers"
      pattern: "from .platforms import YouTubeDownloader, InstagramDownloader, ..."
    - from: "bot/downloaders/platform_router.py"
      to: "bot/downloaders/url_detector.py"
      via: "uses URL classification"
      pattern: "from .url_detector import URLDetector, URLType"
---

<objective>
Implement the platform router that automatically selects the appropriate downloader for any given URL. The router integrates all platform handlers and provides a unified interface for URL-to-downloader routing with priority-based selection and fallback mechanisms.

Purpose: Provide a single entry point for downloading from any supported platform with automatic handler selection.
Output: PlatformRouter class with intelligent URL routing and fallback logic.
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bot/downloaders/platforms/__init__.py
@bot/downloaders/ytdlp_downloader.py
@bot/downloaders/generic_downloader.py
@bot/downloaders/html_extractor.py
@bot/downloaders/url_detector.py
@bot/downloaders/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PlatformRouter with priority-based routing</name>
  <files>bot/downloaders/platform_router.py</files>
  <action>
Create the PlatformRouter class that routes URLs to the appropriate downloader.

Implement:

1. **Imports and types**:
   ```python
   import logging
   from dataclasses import dataclass
   from typing import Optional, Type, List, Dict, Any

   from .base import BaseDownloader, DownloadOptions
   from .url_detector import URLDetector, URLType, classify_url
   from .exceptions import UnsupportedURLError

   # Platform handlers
   from .platforms import (
       YouTubeDownloader,
       InstagramDownloader,
       TikTokDownloader,
       TwitterDownloader,
       FacebookDownloader,
       is_youtube_url,
       is_instagram_url,
       is_tiktok_url,
       is_twitter_url,
       is_facebook_url,
   )
   from .ytdlp_downloader import YtDlpDownloader
   from .generic_downloader import GenericDownloader
   from .html_extractor import HTMLVideoExtractor, download_from_html

   logger = logging.getLogger(__name__)
   ```

2. **RouteResult dataclass**:
   ```python
   @dataclass
   class RouteResult:
       """Result of routing a URL to a downloader.

       Attributes:
           downloader: The selected downloader instance
           platform: Name of the detected platform
           confidence: Confidence level ('high', 'medium', 'low')
           reason: Explanation of why this downloader was selected
       """
       downloader: BaseDownloader
       platform: str
       confidence: str
       reason: str
   ```

3. **PlatformRouter class**:
   ```python
   class PlatformRouter:
       """Routes URLs to the appropriate downloader.

       Uses a priority-based routing system:
       1. Platform-specific handlers (YouTube, Instagram, etc.)
       2. Generic video URL handler
       3. yt-dlp fallback for other platforms
       4. HTML extractor for web pages

       Example:
           router = PlatformRouter()
           result = await router.route('https://youtube.com/watch?v=...')
           # result.downloader is YouTubeDownloader instance
       """

       def __init__(self):
           self._detector = URLDetector()
           self._downloader_cache: Dict[str, BaseDownloader] = {}

           # Platform checkers in priority order
           self._platform_checks = [
               ('youtube', is_youtube_url, YouTubeDownloader),
               ('instagram', is_instagram_url, InstagramDownloader),
               ('tiktok', is_tiktok_url, TikTokDownloader),
               ('twitter', is_twitter_url, TwitterDownloader),
               ('facebook', is_facebook_url, FacebookDownloader),
           ]

           # Fallback downloaders
           self._generic = GenericDownloader()
           self._ytdlp = YtDlpDownloader()
   ```

4. **Route method**:
   ```python
   async def route(self, url: str) -> RouteResult:
       """Route a URL to the appropriate downloader.

       Args:
           url: The URL to route

       Returns:
           RouteResult with selected downloader

       Raises:
           UnsupportedURLError: If no downloader can handle the URL
       """
       if not url or not isinstance(url, str):
           raise UnsupportedURLError("Invalid URL provided")

       logger.debug(f"Routing URL: {url}")

       # Step 1: Check platform-specific handlers (high confidence)
       for platform_name, check_func, downloader_class in self._platform_checks:
           if check_func(url):
               logger.debug(f"Matched {platform_name} platform")
               downloader = self._get_cached_downloader(platform_name, downloader_class)

               # Verify the downloader can actually handle it
               if await downloader.can_handle(url):
                   return RouteResult(
                       downloader=downloader,
                       platform=platform_name,
                       confidence='high',
                       reason=f"URL matches {platform_name} pattern and downloader confirms support",
                   )
               else:
                   logger.warning(f"{platform_name} matched but can_handle returned False")

       # Step 2: Check for direct video URLs (high confidence)
       url_type = classify_url(url)
       if url_type == URLType.GENERIC_VIDEO:
           if await self._generic.can_handle(url):
               return RouteResult(
                   downloader=self._generic,
                   platform='generic_video',
                   confidence='high',
                   reason="URL is a direct video file link",
               )

       # Step 3: Try yt-dlp for other platforms (medium confidence)
       if await self._ytdlp.can_handle(url):
           # Try to identify the platform from yt-dlp info
           platform = await self._identify_platform(url)
           return RouteResult(
               downloader=self._ytdlp,
               platform=platform or 'unknown',
               confidence='medium',
               reason="yt-dlp can handle this URL",
           )

       # Step 4: Check if it's an HTML page that might have videos (low confidence)
       if url_type == URLType.UNKNOWN and self._looks_like_html_page(url):
           return RouteResult(
               downloader=_HTMLExtractorAdapter(self._generic),
               platform='html_page',
               confidence='low',
               reason="URL appears to be an HTML page, will attempt video extraction",
           )

       # No handler found
       raise UnsupportedURLError(
           f"No downloader available for URL: {url}",
           url=url,
       )
   ```

5. **Helper methods**:
   ```python
   def _get_cached_downloader(
       self,
       platform: str,
       downloader_class: Type[BaseDownloader]
   ) -> BaseDownloader:
       """Get or create a downloader instance (cached)."""
       if platform not in self._downloader_cache:
           self._downloader_cache[platform] = downloader_class()
       return self._downloader_cache[platform]

   async def _identify_platform(self, url: str) -> Optional[str]:
       """Try to identify the platform using yt-dlp metadata."""
       try:
           metadata = await self._ytdlp.extract_metadata(
               url,
               DownloadOptions()
           )
           extractor = metadata.get('extractor', '').lower()

           # Map extractor names to platform names
           platform_map = {
               'youtube': 'youtube',
               'instagram': 'instagram',
               'tiktok': 'tiktok',
               'twitter': 'twitter',
               'facebook': 'facebook',
               'vimeo': 'vimeo',
               'dailymotion': 'dailymotion',
               'reddit': 'reddit',
           }

           for key, value in platform_map.items():
               if key in extractor:
                   return value

           return extractor or 'unknown'
       except Exception:
           return None

   def _looks_like_html_page(self, url: str) -> bool:
       """Check if URL looks like an HTML page (not a direct file)."""
       # If URL has no extension or ends with .html/.htm/.php
       import re
       from urllib.parse import urlparse

       parsed = urlparse(url)
       path = parsed.path.lower()

       # No extension suggests HTML page
       if '.' not in path.split('/')[-1]:
           return True

       # Common web page extensions
       html_extensions = {'.html', '.htm', '.php', '.asp', '.aspx', '.jsp'}
       if any(path.endswith(ext) for ext in html_extensions):
           return True

       return False
   ```

6. **Convenience function**:
   ```python
   async def get_downloader_for_url(url: str) -> Optional[BaseDownloader]:
       """Get the appropriate downloader for a URL.

       Convenience function that creates a router and returns
       just the downloader instance.

       Args:
           url: The URL to get a downloader for

       Returns:
           Downloader instance, or None if no handler available
       """
       router = PlatformRouter()
       try:
           result = await router.route(url)
           return result.downloader
       except UnsupportedURLError:
           return None


   async def route_url(url: str) -> RouteResult:
       """Route a URL and return full route result.

       Args:
           url: The URL to route

       Returns:
           RouteResult with downloader and metadata
       """
       router = PlatformRouter()
       return await router.route(url)
   ```

7. **HTML Extractor Adapter** (internal class for routing):
   ```python
   class _HTMLExtractorAdapter(BaseDownloader):
       """Adapter to make HTMLVideoExtractor compatible with BaseDownloader."""

       name = "HTML Video Extractor"
       supported_platforms = ["HTML Pages"]

       def __init__(self, generic_downloader: GenericDownloader):
           self._generic = generic_downloader
           self._extractor = HTMLVideoExtractor()

       async def can_handle(self, url: str) -> bool:
           # Can handle if it looks like an HTML page
           return self._looks_like_html_page(url)

       async def extract_metadata(self, url: str, options: DownloadOptions) -> dict:
           # Extract metadata from first video found
           videos = await self._extractor.extract_videos(url)
           if videos:
               return {
                   'title': 'Video from HTML page',
                   'videos_found': len(videos),
                   'first_video_url': videos[0].url,
                   'source': videos[0].source,
               }
           return {'title': 'HTML page', 'videos_found': 0}

       async def download(self, url: str, options: DownloadOptions) -> Any:
           # Use the download_from_html function
           return await download_from_html(url, options, self._generic)

       def _looks_like_html_page(self, url: str) -> bool:
           # Same implementation as above
           ...
   ```
  </action>
  <verify>
    - PlatformRouter can be instantiated
    - route() returns RouteResult with downloader
    - YouTube URLs route to YouTubeDownloader
    - Instagram URLs route to InstagramDownloader
    - Direct video URLs route to GenericDownloader
    - Unknown URLs that yt-dlp supports route to YtDlpDownloader
    - Unsupported URLs raise UnsupportedURLError
  </verify>
  <done>
    - PlatformRouter class implemented
    - RouteResult dataclass for structured results
    - Priority-based routing (platform-specific -> generic -> yt-dlp -> HTML)
    - Downloader caching for performance
    - Platform identification from yt-dlp metadata
    - Convenience functions get_downloader_for_url and route_url
  </done>
</task>

<task type="auto">
  <name>Task 2: Update URL detector with platform patterns</name>
  <files>bot/downloaders/url_detector.py</files>
  <action>
Update the URL detector to use the platform-specific URL checkers from the platforms module.

1. **Import platform checkers** (at end to avoid circular imports):
   ```python
   # Import platform checkers for enhanced detection
   # Use lazy import to avoid circular dependencies
   def _get_platform_checkers():
       try:
           from .platforms import (
               is_youtube_url,
               is_instagram_url,
               is_tiktok_url,
               is_twitter_url,
               is_facebook_url,
           )
           return {
               'youtube': is_youtube_url,
               'instagram': is_instagram_url,
               'tiktok': is_tiktok_url,
               'twitter': is_twitter_url,
               'facebook': is_facebook_url,
           }
       except ImportError:
           return {}
   ```

2. **Add enhanced classify_url method**:
   ```python
   @staticmethod
   def classify_url_enhanced(url: str) -> tuple[URLType, Optional[str]]:
       """Classify URL with platform identification.

       Returns:
           Tuple of (URLType, platform_name)
       """
       basic_type = URLDetector.classify_url(url)

       if basic_type == URLType.PLATFORM:
           # Try to identify specific platform
           checkers = _get_platform_checkers()
           for platform, checker in checkers.items():
               if checker(url):
                   return URLType.PLATFORM, platform
           return URLType.PLATFORM, 'unknown'

       return basic_type, None
   ```

3. **Update PLATFORM_PATTERNS to include all platforms**:
   ```python
   PLATFORM_PATTERNS = {
       "youtube": [
           r"youtube\.com",
           r"youtu\.be",
           r"youtube\.com/shorts",
       ],
       "instagram": [
           r"instagram\.com/p/",
           r"instagram\.com/reel/",
           r"instagram\.com/reels/",
           r"instagram\.com/stories/",
       ],
       "tiktok": [
           r"tiktok\.com/@",
           r"vm\.tiktok\.com",
           r"vt\.tiktok\.com",
       ],
       "twitter": [
           r"twitter\.com",
           r"x\.com",
       ],
       "facebook": [
           r"facebook\.com/watch",
           r"fb\.watch",
           r"facebook\.com/reel/",
           r"facebook\.com/video",
       ],
   }
   ```

4. **Export new function**:
   ```python
   __all__ = [
       # ... existing exports ...
       'classify_url_enhanced',
   ]
   ```
  </action>
  <verify>
    - classify_url_enhanced returns URLType and platform name
    - YouTube URLs return (PLATFORM, 'youtube')
    - Instagram URLs return (PLATFORM, 'instagram')
    - Generic video URLs return (GENERIC_VIDEO, None)
    - No circular import errors
  </verify>
  <done>
    - classify_url_enhanced function added
    - Platform identification integrated
    - URL patterns updated for all platforms
  </done>
</task>

<task type="auto">
  <name>Task 3: Update package exports and integration</name>
  <files>bot/downloaders/__init__.py</files>
  <action>
Update the main downloaders package to export the router and provide clean imports.

Update bot/downloaders/__init__.py:

```python
"""Downloader package for media URL handling and downloading.

This package provides URL detection, classification, and downloading
capabilities for the Telegram bot. It supports platform-specific
downloads (YouTube, Instagram, TikTok, Twitter/X, Facebook) as well
as generic video URL downloads.

Quick Start:
    # Route URL to appropriate downloader
    from bot.downloaders import route_url
    result = await route_url('https://youtube.com/watch?v=...')

    # Download with automatic handler selection
    downloader = result.downloader
    result = await downloader.download(url, options)

    # Or use the convenience function
    from bot.downloaders import get_downloader_for_url
    downloader = await get_downloader_for_url(url)
"""
import logging

# Set up package logger
logger = logging.getLogger(__name__)

# Import base classes and types
from .base import (
    BaseDownloader,
    DownloadOptions,
    TELEGRAM_MAX_FILE_SIZE,
)

# Import exception hierarchy
from .exceptions import (
    DownloadError,
    DownloadFailedError,
    FileTooLargeError,
    MetadataExtractionError,
    NetworkError,
    URLDetectionError,
    URLValidationError,
    UnsupportedURLError,
)

# Import URL detector components
from .url_detector import (
    URLDetector,
    URLType,
    classify_url,
    classify_url_enhanced,
    detect_urls,
    is_video_url,
)

# Import downloader implementations
from .generic_downloader import GenericDownloader
from .ytdlp_downloader import YtDlpDownloader

# Import platform handlers
from .platforms import (
    # YouTube
    YouTubeDownloader,
    is_youtube_shorts,
    is_youtube_url,
    # Instagram
    InstagramDownloader,
    InstagramContentType,
    is_instagram_reel,
    is_instagram_story,
    # TikTok
    TikTokDownloader,
    is_tiktok_url,
    is_tiktok_slideshow,
    # Twitter/X
    TwitterDownloader,
    is_twitter_url,
    # Facebook
    FacebookDownloader,
    is_facebook_url,
    is_facebook_reel,
)

# Import HTML extractor
from .html_extractor import (
    HTMLVideoExtractor,
    VideoURL,
    extract_videos_from_html,
    download_from_html,
)

# Import platform router (new)
from .platform_router import (
    PlatformRouter,
    RouteResult,
    get_downloader_for_url,
    route_url,
)

# DownloadResult for backwards compatibility
from dataclasses import dataclass
from typing import Optional


@dataclass
class DownloadResult:
    """Result of a download operation.

    Attributes:
        success: Whether the download completed successfully
        file_path: Path to the downloaded file (if successful)
        error_message: Error description (if failed)
        metadata: Additional metadata about the download (title, duration, etc.)
    """
    success: bool
    file_path: Optional[str] = None
    error_message: Optional[str] = None
    metadata: Optional[dict] = None


# Public API exports
__all__ = [
    # Base classes and types
    "BaseDownloader",
    "DownloadOptions",
    "DownloadResult",
    "TELEGRAM_MAX_FILE_SIZE",
    # Exception hierarchy
    "DownloadError",
    "DownloadFailedError",
    "FileTooLargeError",
    "MetadataExtractionError",
    "NetworkError",
    "URLDetectionError",
    "URLValidationError",
    "UnsupportedURLError",
    # URL detection
    "URLDetector",
    "URLType",
    "classify_url",
    "classify_url_enhanced",
    "detect_urls",
    "is_video_url",
    # Downloader implementations
    "GenericDownloader",
    "YtDlpDownloader",
    # Platform handlers
    "YouTubeDownloader",
    "is_youtube_shorts",
    "is_youtube_url",
    "InstagramDownloader",
    "InstagramContentType",
    "is_instagram_reel",
    "is_instagram_story",
    "TikTokDownloader",
    "is_tiktok_url",
    "is_tiktok_slideshow",
    "TwitterDownloader",
    "is_twitter_url",
    "FacebookDownloader",
    "is_facebook_url",
    "is_facebook_reel",
    # HTML extractor
    "HTMLVideoExtractor",
    "VideoURL",
    "extract_videos_from_html",
    "download_from_html",
    # Platform router (new)
    "PlatformRouter",
    "RouteResult",
    "get_downloader_for_url",
    "route_url",
]
```
  </action>
  <verify>
    - All imports work without errors
    - PlatformRouter is exportable
    - RouteResult is exportable
    - get_downloader_for_url and route_url are available
    - No circular import errors
  </verify>
  <done>
    - Package exports updated with router
    - All platform handlers exported
    - Clean public API with documentation
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Import test**: `python -c "from bot.downloaders import PlatformRouter, route_url; print('OK')"`
2. **Routing test**: Test route_url with different platform URLs
3. **Integration test**: Full flow from URL to download

Run comprehensive test:
```python
python -c "
from bot.downloaders import PlatformRouter, route_url, get_downloader_for_url
import asyncio

async def test():
    router = PlatformRouter()

    # Test YouTube
    result = await router.route('https://youtube.com/watch?v=dQw4w9WgXcQ')
    print(f'YouTube: {result.platform} ({result.confidence})')

    # Test generic video
    result = await router.route('https://example.com/video.mp4')
    print(f'Generic: {result.platform} ({result.confidence})')

asyncio.run(test())
"
```
</verification>

<success_criteria>
- PlatformRouter routes URLs to correct downloaders
- YouTube URLs route to YouTubeDownloader
- Instagram URLs route to InstagramDownloader
- TikTok URLs route to TikTokDownloader
- Twitter/X URLs route to TwitterDownloader
- Facebook URLs route to FacebookDownloader
- Generic video URLs route to GenericDownloader
- yt-dlp fallback works for unsupported platforms
- RouteResult provides platform and confidence info
- get_downloader_for_url convenience function works
- Package exports are complete and organized
- No circular import errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-platform-handlers/10-05-SUMMARY.md`
</output>
