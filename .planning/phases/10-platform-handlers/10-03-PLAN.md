---
phase: 10-platform-handlers
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - bot/downloaders/platforms/tiktok.py
  - bot/downloaders/platforms/twitter.py
  - bot/downloaders/platforms/__init__.py
  - bot/downloaders/__init__.py
autonomous: true

must_haves:
  truths:
    - "TikTok videos download without watermark when possible"
    - "TikTok slideshows are detected and can be converted to video"
    - "Twitter/X video posts download with best available quality"
    - "Twitter/X metadata includes tweet text, author, and engagement stats"
  artifacts:
    - path: "bot/downloaders/platforms/tiktok.py"
      provides: "TikTok downloader with watermark-free option"
      exports: ["TikTokDownloader", "is_tiktok_url", "is_tiktok_slideshow"]
      min_lines: 200
    - path: "bot/downloaders/platforms/twitter.py"
      provides: "Twitter/X video downloader"
      exports: ["TwitterDownloader", "is_twitter_url"]
      min_lines: 180
  key_links:
    - from: "bot/downloaders/platforms/tiktok.py"
      to: "bot/downloaders/ytdlp_downloader.py"
      via: "class inheritance"
      pattern: "class TikTokDownloader(YtDlpDownloader)"
    - from: "bot/downloaders/platforms/twitter.py"
      to: "bot/downloaders/ytdlp_downloader.py"
      via: "class inheritance"
      pattern: "class TwitterDownloader(YtDlpDownloader)"
---

<objective>
Implement TikTok and Twitter/X downloaders. TikTok downloader focuses on watermark-free downloads when possible and slideshow detection. Twitter/X downloader extracts tweet metadata including text, author, and engagement stats.

Purpose: Provide optimized downloading for TikTok (TT-01, TT-02) and Twitter/X (TW-01, TW-02) with platform-specific features.
Output: TikTokDownloader and TwitterDownloader classes with enhanced metadata.
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bot/downloaders/ytdlp_downloader.py
@bot/downloaders/base.py
@bot/downloaders/platforms/youtube.py
@bot/downloaders/platforms/instagram.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TikTokDownloader with watermark-free option</name>
  <files>bot/downloaders/platforms/tiktok.py</files>
  <action>
Create the TikTokDownloader class with watermark-free download support and slideshow detection.

Implement:

1. **TikTok URL patterns**:
   ```python
   TIKTOK_PATTERNS = [
       r'tiktok\.com/@[\w.]+/video/\d+',
       r'tiktok\.com/t/\w+',
       r'vm\.tiktok\.com/\w+',
       r'vt\.tiktok\.com/\w+',
       r'tiktok\.com/\w+/video/\d+',  # Mobile app share URLs
   ]
   ```

2. **Helper functions**:
   ```python
   def is_tiktok_url(url: str) -> bool:
       """Check if URL is a TikTok URL."""
       patterns = [
           r'tiktok\.com',
           r'vm\.tiktok\.com',
           r'vt\.tiktok\.com',
       ]
       return any(re.search(p, url.lower()) for p in patterns)

   def is_tiktok_slideshow(info: dict) -> bool:
       """Check if TikTok content is a slideshow (multiple images)."""
       # Slideshows have specific format indicators
       formats = info.get('formats', [])
       # Check for image formats or slideshow indicator
       for fmt in formats:
           if fmt.get('format_id') == 'slideshow':
               return True
       # Alternative: check if video has no video stream but has images
       return info.get('album') is not None or 'slideshow' in str(info.get('formats', [])).lower()

   def extract_tiktok_id(url: str) -> Optional[str]:
       """Extract TikTok video ID from URL."""
       patterns = [
           r'/video/(\d+)',
           r'/t/(\w+)',
       ]
       for pattern in patterns:
           match = re.search(pattern, url)
           if match:
               return match.group(1)
       return None
   ```

3. **TikTokDownloader class**:
   ```python
   class TikTokDownloader(YtDlpDownloader):
       """TikTok downloader with watermark-free option and slideshow support."""

       @property
       def name(self) -> str:
           return "TikTok Downloader"

       @property
       def supported_platforms(self) -> list[str]:
           return ["TikTok"]

       def __init__(self, prefer_watermark_free: bool = True):
           super().__init__()
           self.prefer_watermark_free = prefer_watermark_free
   ```

4. **Override can_handle(url: str) -> bool**:
   - Return True if is_tiktok_url(url) returns True
   - Validate with super().can_handle() as secondary check

5. **Override _build_ydl_options() for watermark-free preference**:
   ```python
   def _build_ydl_options(self, options: DownloadOptions, output_path: str, correlation_id: str) -> dict:
       ydl_opts = super()._build_ydl_options(options, output_path, correlation_id)

       # TikTok-specific options for watermark-free
       if self.prefer_watermark_free:
           # Use format that prefers watermark-free versions
           # Note: yt-dlp may not always be able to remove watermarks
           # This is a best-effort approach
           ydl_opts['format'] = 'best[format_id!*=watermark]/best'

       # Add extractor args for TikTok
       ydl_opts['extractor_args'] = {
           'tiktok': {
               'api_hostname': 'api16-normal-c-useast1a.tiktokv.com',
               'app_version': '20.9.3',
           }
       }

       return ydl_opts
   ```

6. **Override extract_metadata() for TikTok-specific fields**:
   ```python
   async def extract_metadata(self, url: str, options: DownloadOptions) -> dict[str, Any]:
       metadata = await super().extract_metadata(url, options)

       # Add TikTok-specific fields
       info = metadata.get('_raw_info', {})

       metadata['tiktok_id'] = extract_tiktok_id(url)
       metadata['author'] = info.get('uploader') or info.get('creator')
       metadata['author_id'] = info.get('uploader_id')
       metadata['description'] = info.get('description', '')
       metadata['stats'] = {
           'plays': info.get('view_count'),
           'likes': info.get('like_count'),
           'shares': info.get('repost_count'),
           'comments': info.get('comment_count'),
       }

       # Detect slideshow
       metadata['is_slideshow'] = is_tiktok_slideshow(info)

       # Music info
       metadata['music'] = {
           'title': info.get('track'),
           'author': info.get('artist'),
       }

       # Aspect ratio (TikTok is always 9:16)
       metadata['aspect_ratio'] = '9:16'

       return metadata
   ```

7. **Slideshow handling (TT-02)**:
   ```python
   async def download_slideshow(self, url: str, options: DownloadOptions) -> Any:
       """Download TikTok slideshow as video or images.

       For slideshows, we can either:
       1. Download all images and let user choose
       2. Convert to video (requires ffmpeg)

       For now, extract image URLs and return metadata.
       """
       metadata = await self.extract_metadata(url, options)

       if not metadata.get('is_slideshow'):
           raise ValueError("URL is not a TikTok slideshow")

       # Slideshow handling - return info about images
       # Full implementation would download images or convert to video
       from .. import DownloadResult

       return DownloadResult(
           success=True,
           file_path=None,  # Would be populated with actual path
           metadata={
               'is_slideshow': True,
               'message': 'Slideshow detected. Image download not yet implemented.',
               'image_count': metadata.get('image_count', 0),
           }
       )
   ```

8. **Error handling**:
   - Handle "Video not available" (content removed)
   - Handle "Country restricted" (region-locked content)
   - Handle rate limiting from TikTok

Example metadata:
```python
{
    'title': 'Video by @username',
    'duration': 15,
    'uploader': '@username',
    'thumbnail': 'https://p16-sign.tiktokcdn.com/...',
    'filesize': 3145728,
    'tiktok_id': '1234567890',
    'author': '@username',
    'author_id': 'user_id',
    'description': 'Video caption #hashtag',
    'stats': {
        'plays': 1000000,
        'likes': 50000,
        'shares': 10000,
        'comments': 5000,
    },
    'is_slideshow': False,
    'music': {
        'title': 'Original Sound',
        'author': '@username',
    },
    'aspect_ratio': '9:16',
}
```
  </action>
  <verify>
    - TikTokDownloader can be instantiated
    - is_tiktok_url returns True for tiktok.com URLs
    - is_tiktok_url returns True for vm.tiktok.com URLs
    - extract_tiktok_id returns video ID from URL
    - Metadata includes author, stats, music info
    - Slideshow detection works
    - Aspect ratio is always 9:16
  </verify>
  <done>
    - TikTokDownloader extends YtDlpDownloader
    - Watermark-free format preference configured
    - TikTok-specific metadata (author, stats, music)
    - Slideshow detection implemented
    - Aspect ratio hint for vertical video
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement TwitterDownloader with quality selection</name>
  <files>bot/downloaders/platforms/twitter.py</files>
  <action>
Create the TwitterDownloader class with quality selection and tweet metadata extraction.

Implement:

1. **Twitter/X URL patterns**:
   ```python
   TWITTER_PATTERNS = [
       r'twitter\.com/\w+/status/\d+',
       r'x\.com/\w+/status/\d+',
       r'twitter\.com/i/spaces/\d+',  # Spaces (audio only)
   ]
   ```

2. **Helper functions**:
   ```python
   def is_twitter_url(url: str) -> bool:
       """Check if URL is a Twitter/X URL."""
       patterns = [
           r'twitter\.com',
           r'x\.com',
       ]
       return any(re.search(p, url.lower()) for p in patterns)

   def extract_tweet_id(url: str) -> Optional[str]:
       """Extract tweet ID from URL."""
       match = re.search(r'/status/(\d+)', url)
       if match:
           return match.group(1)
       return None

   def extract_username(url: str) -> Optional[str]:
       """Extract username from Twitter URL."""
       match = re.search(r'(?:twitter|x)\.com/(\w+)/status/', url.lower())
       if match:
           return match.group(1)
       return None
   ```

3. **TwitterDownloader class**:
   ```python
   class TwitterDownloader(YtDlpDownloader):
       """Twitter/X video downloader with quality selection."""

       @property
       def name(self) -> str:
           return "Twitter/X Downloader"

       @property
       def supported_platforms(self) -> list[str]:
           return ["Twitter", "X"]
   ```

4. **Override can_handle(url: str) -> bool**:
   - Return True if is_twitter_url(url) returns True
   - Check that URL contains /status/ (tweet URL)
   - Validate with super().can_handle()

5. **Override extract_metadata() for Twitter-specific fields**:
   ```python
   async def extract_metadata(self, url: str, options: DownloadOptions) -> dict[str, Any]:
       metadata = await super().extract_metadata(url, options)

       # Add Twitter-specific fields
       info = metadata.get('_raw_info', {})

       metadata['tweet_id'] = extract_tweet_id(url)
       metadata['username'] = extract_username(url) or info.get('uploader')
       metadata['display_name'] = info.get('uploader')
       metadata['tweet_text'] = info.get('description', '')
       metadata['created_at'] = info.get('timestamp')

       # Engagement stats
       metadata['engagement'] = {
           'replies': info.get('comment_count'),
           'retweets': info.get('repost_count'),
           'likes': info.get('like_count'),
           'views': info.get('view_count'),
       }

       # Video variants (quality options) (TW-02)
       formats = info.get('formats', [])
       video_formats = [f for f in formats if f.get('vcodec') != 'none']
       metadata['video_variants'] = [
           {
               'format_id': f.get('format_id'),
               'resolution': f.get('resolution'),
               'filesize': f.get('filesize'),
               'bitrate': f.get('tbr'),
           }
           for f in sorted(video_formats,
                          key=lambda x: x.get('height', 0) or 0,
                          reverse=True)
       ]

       # Check if has video
       metadata['has_video'] = len(video_formats) > 0
       metadata['is_gif'] = 'gif' in str(info.get('formats', [])).lower()

       return metadata
   ```

6. **Quality selection helper (TW-02)**:
   ```python
   def select_best_variant(self, variants: list, max_size: int) -> Optional[str]:
       """Select best video variant under size limit.

       Args:
           variants: List of video variant dicts
           max_size: Maximum file size in bytes

       Returns:
           format_id of best variant, or None
       """
       for variant in variants:
           filesize = variant.get('filesize', 0) or 0
           if filesize and filesize <= max_size:
               return variant['format_id']

       # If no size info or all too large, return highest quality
       return variants[0]['format_id'] if variants else None

   def _build_ydl_options(self, options: DownloadOptions, output_path: str, correlation_id: str) -> dict:
       ydl_opts = super()._build_ydl_options(options, output_path, correlation_id)

       # Twitter-specific: prefer MP4 format
       ydl_opts['format'] = 'best[ext=mp4]/best'

       return ydl_opts
   ```

7. **Error handling**:
   - Handle "Tweet not found" (deleted tweet)
   - Handle "Account suspended"
   - Handle "Age-restricted content"
   - Handle private accounts

Example metadata:
```python
{
    'title': 'Tweet by @username',
    'duration': 30,
    'uploader': '@username',
    'thumbnail': 'https://pbs.twimg.com/...',
    'filesize': 10485760,
    'tweet_id': '1234567890123456789',
    'username': 'username',
    'display_name': 'Display Name',
    'tweet_text': 'Tweet text content...',
    'created_at': 1705315200,
    'engagement': {
        'replies': 100,
        'retweets': 500,
        'likes': 2000,
        'views': 50000,
    },
    'video_variants': [
        {'format_id': 'http-720', 'resolution': '720x1280', 'filesize': 10485760, 'bitrate': 2000},
        {'format_id': 'http-480', 'resolution': '480x854', 'filesize': 5242880, 'bitrate': 1000},
    ],
    'has_video': True,
    'is_gif': False,
}
```
  </action>
  <verify>
    - TwitterDownloader can be instantiated
    - is_twitter_url returns True for twitter.com and x.com URLs
    - extract_tweet_id returns tweet ID from URL
    - extract_username returns username from URL
    - Metadata includes tweet_text, engagement stats
    - video_variants list is populated with quality options
    - has_video indicates if tweet contains video
  </verify>
  <done>
    - TwitterDownloader extends YtDlpDownloader
    - Tweet metadata extraction (text, engagement stats)
    - Video variants list for quality selection (TW-02)
    - Helper to select best variant under size limit
    - GIF detection
  </done>
</task>

<task type="auto">
  <name>Task 3: Update package exports</name>
  <files>bot/downloaders/platforms/__init__.py, bot/downloaders/__init__.py</files>
  <action>
Update package exports to include TikTok and Twitter downloaders.

1. Update bot/downloaders/platforms/__init__.py:
```python
from .tiktok import (
    TikTokDownloader,
    is_tiktok_url,
    is_tiktok_slideshow,
    extract_tiktok_id,
)
from .twitter import (
    TwitterDownloader,
    is_twitter_url,
    extract_tweet_id,
    extract_username,
)

__all__ = [
    # YouTube (from 10-01)
    'YouTubeDownloader',
    'is_youtube_url',
    'is_youtube_shorts',
    # Instagram (from 10-02)
    'InstagramDownloader',
    'InstagramContentType',
    'detect_instagram_content_type',
    'is_instagram_reel',
    'is_instagram_story',
    'is_instagram_url',
    'extract_shortcode',
    # TikTok
    'TikTokDownloader',
    'is_tiktok_url',
    'is_tiktok_slideshow',
    'extract_tiktok_id',
    # Twitter/X
    'TwitterDownloader',
    'is_twitter_url',
    'extract_tweet_id',
    'extract_username',
]
```

2. Update bot/downloaders/__init__.py:
```python
from .platforms import (
    # YouTube
    YouTubeDownloader,
    is_youtube_shorts,
    is_youtube_url,
    # Instagram
    InstagramDownloader,
    InstagramContentType,
    is_instagram_reel,
    is_instagram_story,
    # TikTok
    TikTokDownloader,
    is_tiktok_url,
    is_tiktok_slideshow,
    # Twitter/X
    TwitterDownloader,
    is_twitter_url,
)
```
  </action>
  <verify>
    - TikTokDownloader and TwitterDownloader are importable
    - Helper functions are exportable
    - No circular import errors
  </verify>
  <done>
    - TikTok and Twitter handlers exported
    - All helper functions available
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Import tests**:
   - `python -c "from bot.downloaders import TikTokDownloader; print('OK')"`
   - `python -c "from bot.downloaders import TwitterDownloader; print('OK')"`
2. **URL detection**: Test is_tiktok_url and is_twitter_url
3. **Metadata**: Verify TikTok stats and Twitter engagement are extracted
4. **Quality variants**: Verify Twitter video_variants list

Run: `python -c "from bot.downloaders.platforms import TikTokDownloader, TwitterDownloader; print('Both OK')"`
</verification>

<success_criteria>
- TikTokDownloader extends YtDlpDownloader correctly
- TikTok watermark-free preference configured
- TikTok metadata includes author, stats, music info
- Slideshow detection working
- TwitterDownloader extends YtDlpDownloader correctly
- Twitter metadata includes tweet text, engagement stats
- Video variants list populated for quality selection (TW-02)
- Package exports updated correctly
- No breaking changes to existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/10-platform-handlers/10-03-SUMMARY.md`
</output>
