---
phase: 03-voice-notes-voice-message-processing
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - bot/handlers.py
autonomous: true

must_haves:
  truths:
    - "Usuario puede enviar archivo MP3 y recibir nota de voz de Telegram"
    - "Archivos MP3 de más de 20 minutos son truncados automáticamente"
    - "El bot detecta archivos de audio (MP3, OGG, WAV, AAC) automáticamente"
    - "Conversión preserva calidad de audio razonable"
  artifacts:
    - path: "bot/handlers.py"
      provides: "Handler para archivos de audio a voice notes"
      contains: "handle_audio_file"
      exports: ["handle_audio_file"]
    - path: "bot/main.py"
      provides: "Registro de handler de audio"
      contains: "filters.AUDIO"
  key_links:
    - from: "bot/handlers.py"
      to: "bot/audio_processor.py"
      via: "VoiceNoteConverter"
      pattern: "VoiceNoteConverter.*process"
    - from: "bot/handlers.py"
      to: "bot/validators.py"
      via: "validate_audio_file"
      pattern: "validate_audio_file"
---

<objective>
Implementar el handler para convertir archivos de audio (MP3, OGG, WAV, AAC) enviados por el usuario a notas de voz de Telegram (voice notes) en formato OGG Opus.

Purpose: Permitir a los usuarios enviar archivos de audio y recibirlos como voice notes reproducibles directamente en Telegram.
Output: Handler handle_audio_file en bot/handlers.py que procesa archivos de audio y los envía como voice notes.
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@bot/handlers.py
@bot/audio_processor.py
@bot/validators.py
@bot/config.py
@bot/temp_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implementar handle_audio_file handler</name>
  <files>bot/handlers.py</files>
  <action>
Agregar la función `handle_audio_file` a `bot/handlers.py`:

1. Importar VoiceNoteConverter desde bot.audio_processor

2. Agregar función `handle_audio_file(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None`:
   - Obtener el archivo de audio de update.message.audio
   - Generar correlation_id con uuid
   - Validar tamaño del archivo usando validate_file_size (ya importado)
   - Enviar mensaje "Procesando audio..." al usuario

3. Usar TempManager como context manager para limpieza automática:
   ```python
   with TempManager() as temp_mgr:
       # procesamiento
   ```

4. Dentro del context manager:
   - Generar nombres de archivo seguros: input_{user_id}_{file_unique_id}.mp3
   - Descargar archivo usando _download_with_retry (ya existe)
   - Validar archivo con validate_audio_file (de 03-01)
   - Obtener duración con get_audio_duration
   - Verificar si excede MAX_VOICE_DURATION_MINUTES y loggear warning si se truncará
   - Verificar espacio en disco con check_disk_space

5. Procesar con VoiceNoteConverter:
   ```python
   converter = VoiceNoteConverter(str(input_path), str(output_path))
   success = await asyncio.wait_for(
       loop.run_in_executor(None, converter.process),
       timeout=config.PROCESSING_TIMEOUT
   )
   ```

6. Enviar resultado:
   - Si éxito: usar update.message.reply_voice(voice=open(output_path, "rb"))
   - Eliminar mensaje de "Procesando..." en éxito
   - Manejar errores con handle_processing_error

7. Manejar errores específicos:
   - DownloadError: "No pude descargar el audio"
   - ValidationError: errores de validación
   - asyncio.TimeoutError: "El audio tardó demasiado en procesarse"

IMPORTANTE: Seguir EXACTAMENTE el patrón de handle_video y handle_extract_audio_command. Usar los mismos patrones de logging con correlation_id.
  </action>
  <verify>
python -c "from bot.handlers import handle_audio_file; print('handle_audio_file imported OK')"
  </verify>
  <done>Handler handle_audio_file implementado con validación y conversión a voice note</done>
</task>

<task type="auto">
  <name>Task 2: Agregar error específico para conversión de voz</name>
  <files>bot/error_handler.py</files>
  <action>
Agregar clase de error específica para conversión de voice notes en `bot/error_handler.py`:

1. Agregar clase `VoiceConversionError`:
   ```python
   class VoiceConversionError(VideoProcessingError):
       """Exception raised when voice note conversion fails."""
       def __init__(self, message: str = "Error convirtiendo a nota de voz"):
           self.message = message
           super().__init__(self.message)
   ```

2. Agregar entrada a ERROR_MESSAGES:
   ```python
   VoiceConversionError: "No pude convertir el audio a nota de voz. Verifica que el archivo sea válido.",
   ```

3. Exportar en __all__ si existe, o asegurar que esté disponible para importación

IMPORTANTE: Mantener consistencia con errores existentes. Mensaje en español para el usuario.
  </action>
  <verify>
python -c "from bot.error_handler import VoiceConversionError; print('VoiceConversionError imported OK')"
  </verify>
  <done>Clase VoiceConversionError agregada a error_handler.py</done>
</task>

</tasks>

<verification>
- [ ] handle_audio_file existe en bot/handlers.py
- [ ] Usa TempManager como context manager
- [ ] Valida archivo con validate_audio_file
- [ ] Usa VoiceNoteConverter para conversión
- [ ] Envía resultado como reply_voice
- [ ] Maneja errores con handle_processing_error
- [ ] VoiceConversionError existe en error_handler.py
- [ ] Mensajes de error en español
</verification>

<success_criteria>
1. Handler handle_audio_file implementado y funcional
2. Conversión MP3 → OGG Opus voice note funciona
3. Archivos > 20 minutos son truncados automáticamente
4. Errores manejados apropiadamente con mensajes en español
5. Limpieza de archivos temporales garantizada
</success_criteria>

<output>
After completion, create `.planning/phases/03-voice-notes-voice-message-processing/03-02-SUMMARY.md`
</output>
