---
phase: 03-voice-notes-voice-message-processing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/audio_processor.py
  - bot/config.py
  - bot/validators.py
  - bot/error_handler.py
autonomous: true

must_haves:
  truths:
    - "Existe clase VoiceNoteConverter que convierte MP3 a OGG Opus"
    - "Existe clase VoiceToMp3Converter que convierte notas de voz a MP3"
    - "Validación de duración máxima (20 minutos) implementada"
    - "Configuración soporta parámetros de audio"
  artifacts:
    - path: "bot/audio_processor.py"
      provides: "Conversión de audio entre formatos"
      min_lines: 150
      exports: ["VoiceNoteConverter", "VoiceToMp3Converter"]
    - path: "bot/config.py"
      provides: "Configuración de audio agregada"
      contains: "MAX_VOICE_DURATION_MINUTES"
    - path: "bot/validators.py"
      provides: "Validación de archivos de audio"
      exports: ["validate_audio_file", "get_audio_duration"]
    - path: "bot/error_handler.py"
      provides: "Errores específicos de audio"
      exports: ["VoiceConversionError", "VoiceToMp3Error"]
  key_links:
    - from: "bot/audio_processor.py"
      to: "ffmpeg"
      via: "subprocess con codec libopus"
      pattern: "libopus.*ogg"
    - from: "bot/validators.py"
      to: "ffprobe"
      via: "subprocess para obtener duración"
      pattern: "ffprobe.*duration"
---

<objective>
Crear el módulo de procesamiento de audio con clases para convertir MP3 a notas de voz (OGG Opus) y notas de voz a MP3.

Purpose: Establecer la infraestructura base de procesamiento de audio que soporta las dos direcciones de conversión requeridas por la fase.
Output: bot/audio_processor.py con VoiceNoteConverter y VoiceToMp3Converter, configuración y validación actualizadas.
</objective>

<execution_context>
@/data/data/com.termux/files/home/.claude/get-shit-done/workflows/execute-plan.md
@/data/data/com.termux/files/home/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@bot/format_processor.py
@bot/video_processor.py
@bot/config.py
@bot/validators.py
@bot/error_handler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Crear bot/audio_processor.py con clases de conversión</name>
  <files>bot/audio_processor.py</files>
  <action>
Crear `bot/audio_processor.py` siguiendo el patrón de `bot/video_processor.py` y `bot/format_processor.py`:

1. Importar shutil, subprocess, logging, Path

2. Crear clase `VoiceNoteConverter`:
   - `__init__(self, input_path: str, output_path: str)`
   - `process(self) -> bool`: Convierte MP3 (u otros formatos) a OGG Opus para voice notes
   - Método estático `_check_ffmpeg() -> bool`
   - Constante `MAX_DURATION_SECONDS = 1200` (20 minutos)
   - Usar ffmpeg con: `-c:a libopus`, `-b:a 24k` (bitrate optimizado para voz), formato OGG
   - Si el audio excede 20 minutos, truncar con `-t 1200`
   - Manejar errores con logging apropiado

3. Crear clase `VoiceToMp3Converter`:
   - `__init__(self, input_path: str, output_path: str)`
   - `process(self) -> bool`: Convierte notas de voz (OGG Opus) a MP3
   - Usar ffmpeg con: `-c:a libmp3lame`, `-b:a 192k` (buena calidad para voz)
   - Preservar metadatos si existen
   - Manejar errores con logging apropiado

4. Métodos estáticos auxiliares:
   - `get_audio_duration(file_path: str) -> float`: Usar ffprobe para obtener duración
   - `is_opus_ogg(file_path: str) -> bool`: Verificar si es formato voice note válido

IMPORTANTE: Seguir exactamente el patrón de manejo de errores de video_processor.py. Todos los mensajes de log en inglés (consistencia con codebase existente).
  </action>
  <verify>
python -c "from bot.audio_processor import VoiceNoteConverter, VoiceToMp3Converter; print('Audio processor imports OK')"
  </verify>
  <done>bot/audio_processor.py existe con ambas clases de conversión implementadas</done>
</task>

<task type="auto">
  <name>Task 2: Agregar configuración de audio a bot/config.py</name>
  <files>bot/config.py</files>
  <action>
Actualizar `bot/config.py` para agregar configuración específica de audio:

1. Agregar campos al dataclass `BotConfig`:
   - `MAX_VOICE_DURATION_MINUTES: int = 20` (límite de Telegram para voice notes)
   - `MAX_AUDIO_FILE_SIZE_MB: int = 20` (límite de tamaño para archivos de audio)
   - `VOICE_BITRATE: str = "24k"` (bitrate optimizado para voz)
   - `MP3_BITRATE: str = "192k"` (bitrate para conversión a MP3)

2. Agregar validación en `__post_init__`:
   - Validar que MAX_VOICE_DURATION_MINUTES sea positivo (max 20)
   - Validar que MAX_AUDIO_FILE_SIZE_MB sea positivo

3. Agregar al `load_config()`:
   - `_int_env("MAX_VOICE_DURATION_MINUTES", 20)`
   - `_int_env("MAX_AUDIO_FILE_SIZE_MB", 20)`
   - `os.getenv("VOICE_BITRATE", "24k")`
   - `os.getenv("MP3_BITRATE", "192k")`

IMPORTANTE: Mantener frozen=True en el dataclass. Los valores por defecto deben ser conservadores para evitar problemas con límites de Telegram.
  </action>
  <verify>
python -c "from bot.config import config; print(f'Max voice duration: {config.MAX_VOICE_DURATION_MINUTES}min'); print(f'Voice bitrate: {config.VOICE_BITRATE}')"
  </verify>
  <done>Configuración de audio agregada con valores por defecto conservadores</done>
</task>

<task type="auto">
  <name>Task 3: Agregar validación de audio a bot/validators.py</name>
  <files>bot/validators.py</files>
  <action>
Actualizar `bot/validators.py` para agregar validación específica de archivos de audio:

1. Agregar función `get_audio_duration(file_path: str) -> Tuple[Optional[float], Optional[str]]`:
   - Usar ffprobe para obtener duración del audio
   - Retornar (duration, None) si éxito, (None, error_message) si falla
   - Manejar casos: archivo no existe, no tiene stream de audio, ffprobe no disponible
   - Mensajes de error en español (consistente con validadores existentes)

2. Agregar función `validate_audio_file(file_path: str) -> Tuple[bool, Optional[str]]`:
   - Similar a validate_video_file pero para audio
   - Verificar que archivo existe y no está vacío
   - Verificar que tiene al menos un stream de audio usando ffprobe
   - Verificar duración válida (> 0)
   - Retornar (True, None) si válido, (False, error_message) si no
   - Mensajes de error en español

3. Agregar función `validate_audio_duration(file_path: str, max_minutes: int) -> Tuple[bool, Optional[str]]`:
   - Verificar que duración no excede max_minutes
   - Retornar mensaje en español si excede: "El audio es demasiado largo (máximo {max_minutes} minutos)"

IMPORTANTE: Seguir exactamente el patrón de las funciones de validación de video existentes. Manejar FileNotFoundError para ffprobe gracefulmente (log warning, no fallar).
  </action>
  <verify>
python -c "from bot.validators import get_audio_duration, validate_audio_file, validate_audio_duration; print('Audio validators imported OK')"
  </verify>
  <done>Funciones de validación de audio implementadas con mensajes en español</done>
</task>

</tasks>

<verification>
- [ ] bot/audio_processor.py tiene VoiceNoteConverter y VoiceToMp3Converter
- [ ] Ambas clases tienen método process() que retorna bool
- [ ] VoiceNoteConverter trunca audio > 20 minutos
- [ ] VoiceNoteConverter usa codec libopus y formato OGG
- [ ] VoiceToMp3Converter usa codec libmp3lame
- [ ] bot/config.py tiene MAX_VOICE_DURATION_MINUTES = 20
- [ ] bot/config.py tiene VOICE_BITRATE y MP3_BITRATE
- [ ] bot/validators.py tiene get_audio_duration usando ffprobe
- [ ] bot/validators.py tiene validate_audio_file
- [ ] Todas las validaciones retornan mensajes en español
</verification>

<success_criteria>
1. Módulo audio_processor.py creado con dos clases de conversión
2. Configuración de audio agregada a config.py
3. Validación de audio implementada en validators.py
4. Todos los imports funcionan sin errores
5. Patrones consistentes con código existente (video_processor.py)
</success_criteria>

<output>
After completion, create `.planning/phases/03-voice-notes-voice-message-processing/03-01-SUMMARY.md`
</output>
